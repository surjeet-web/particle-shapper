<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>100+ Shape Morphing Particle Network</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            color: #fff;
        }
        
        canvas {
            display: block;
        }
        
        #info {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.7);
            font-size: 18px;
            z-index: 10;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #gui {
            position: absolute;
            top: 15px;
            right: 15px;
            max-height: 85vh;
            overflow-y: auto;
            background: rgba(20, 20, 40, 0.85);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            z-index: 20;
            width: 320px;
        }
        
        .gui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 15px;
        }
        
        .gui-title {
            font-size: 22px;
            font-weight: 600;
            background: linear-gradient(45deg, #00aaff, #00ffcc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .gui-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .section-title {
            font-size: 18px;
            margin-bottom: 15px;
            color: #00aaff;
            display: flex;
            align-items: center;
        }
        
        .section-title i {
            margin-right: 10px;
            font-size: 20px;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #a0a0d0;
        }
        
        input[type="range"], input[type="color"], select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            color: white;
            outline: none;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(100, 150, 255, 0.2);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00aaff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 170, 255, 0.5);
        }
        
        button {
            background: linear-gradient(45deg, #00aaff, #0077ff);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
            margin-top: 5px;
            box-shadow: 0 4px 15px rgba(0, 100, 255, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 100, 255, 0.5);
        }
        
        .shapes-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .shape-btn {
            background: rgba(30, 40, 80, 0.7);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(100, 150, 255, 0.2);
            font-size: 13px;
        }
        
        .shape-btn:hover {
            background: rgba(50, 70, 140, 0.7);
            transform: translateY(-3px);
        }
        
        .shape-category {
            margin-top: 15px;
        }
        
        .shape-category-title {
            font-size: 16px;
            color: #00ccff;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .custom-shapes {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }
        
        .save-section {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        #shape-name {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            color: white;
            outline: none;
        }
        
        .saved-shapes {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .saved-shape {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(40, 40, 80, 0.5);
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .saved-shape-name {
            font-size: 14px;
        }
        
        .saved-shape-actions {
            display: flex;
            gap: 5px;
        }
        
        .action-btn {
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 5px;
        }
        
        .morph-btn {
            background: linear-gradient(45deg, #00cc88, #00aa66);
        }
        
        .delete-btn {
            background: linear-gradient(45deg, #ff5577, #cc3355);
        }
        
        .stats {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .toggle-gui {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(20, 20, 40, 0.85);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 30;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .toggle-gui i {
            font-size: 24px;
            color: #00aaff;
        }
        
        /* Hide scrollbars */
        .shapes-container::-webkit-scrollbar,
        .saved-shapes::-webkit-scrollbar {
            display: none;
        }
        
        .shapes-container,
        .saved-shapes {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        .hidden {
            display: none;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 170, 255, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .notification.show {
            opacity: 1;
        }
        
        .shape-search {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            color: white;
            outline: none;
            margin-bottom: 10px;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div id="info">Click: Morph Shape | Ctrl+Click: Save Shape | Right-click: Change Particle Style</div>
    
    <div class="toggle-gui" id="toggle-gui">
        <i class="fas fa-sliders-h"></i>
    </div>
    
    <div id="gui">
        <div class="gui-header">
            <div class="gui-title">Particle Network</div>
            <div class="gui-version">v3.0</div>
        </div>
        
        <div class="gui-section">
            <div class="section-title">
                <i class="fas fa-palette"></i>Appearance
            </div>
            <div class="controls-grid">
                <div class="control-group">
                    <label class="control-label">Particle Count</label>
                    <input type="range" id="particleCount" min="1000" max="20000" step="100" value="8000">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Particle Size</label>
                    <input type="range" id="particleSize" min="0.1" max="5" step="0.1" value="1.5">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Opacity</label>
                    <input type="range" id="particleOpacity" min="0.1" max="1" step="0.05" value="0.9">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Base Color</label>
                    <input type="color" id="baseColor" value="#00aaff">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Highlight Color</label>
                    <input type="color" id="highlightColor" value="#ff00aa">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Particle Style</label>
                    <select id="particleType">
                        <option value="circle">Circle</option>
                        <option value="square">Square</option>
                        <option value="star">Star</option>
                        <option value="glow">Glow</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="gui-section">
            <div class="section-title">
                <i class="fas fa-cogs"></i>Animation
            </div>
            <div class="controls-grid">
                <div class="control-group">
                    <label class="control-label">Morph Speed</label>
                    <input type="range" id="morphSpeed" min="0.001" max="0.1" step="0.001" value="0.02">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Rotation X</label>
                    <input type="range" id="rotationSpeedX" min="-0.01" max="0.01" step="0.001" value="0.001">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Rotation Y</label>
                    <input type="range" id="rotationSpeedY" min="-0.01" max="0.01" step="0.001" value="0.002">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Auto Morph</label>
                    <input type="checkbox" id="autoMorph" checked>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Morph Delay (ms)</label>
                    <input type="range" id="autoMorphDelay" min="1000" max="10000" step="100" value="3000">
                </div>
            </div>
        </div>
        
        <div class="gui-section">
            <div class="section-title">
                <i class="fas fa-plug"></i>Connections
            </div>
            <div class="controls-grid">
                <div class="control-group">
                    <label class="control-label">Density</label>
                    <input type="range" id="connectionDensity" min="0" max="0.1" step="0.005" value="0.02">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Width</label>
                    <input type="range" id="connectionWidth" min="0.1" max="3" step="0.1" value="0.8">
                </div>
            </div>
        </div>
        
        <div class="gui-section">
            <div class="section-title">
                <i class="fas fa-shapes"></i>Shapes (100+)
            </div>
            
            <input type="text" id="shape-search" class="shape-search" placeholder="Search shapes...">
            
            <div class="shape-category">
                <div class="shape-category-title">
                    <i class="fas fa-globe"></i> Basic 3D
                </div>
                <div class="shapes-container" id="basic-shapes">
                    <!-- Basic shapes will be added here -->
                </div>
            </div>
            
            <div class="shape-category">
                <div class="shape-category-title">
                    <i class="fas fa-atom"></i> Scientific
                </div>
                <div class="shapes-container" id="scientific-shapes">
                    <!-- Scientific shapes will be added here -->
                </div>
            </div>
            
            <div class="shape-category">
                <div class="shape-category-title">
                    <i class="fas fa-heart"></i> Organic
                </div>
                <div class="shapes-container" id="organic-shapes">
                    <!-- Organic shapes will be added here -->
                </div>
            </div>
            
            <div class="shape-category">
                <div class="shape-category-title">
                    <i class="fas fa-project-diagram"></i> Mathematical
                </div>
                <div class="shapes-container" id="math-shapes">
                    <!-- Math shapes will be added here -->
                </div>
            </div>
            
            <div class="shape-category">
                <div class="shape-category-title">
                    <i class="fas fa-city"></i> Structural
                </div>
                <div class="shapes-container" id="structural-shapes">
                    <!-- Structural shapes will be added here -->
                </div>
            </div>
        </div>
        
        <div class="custom-shapes">
            <div class="section-title">
                <i class="fas fa-plus-circle"></i>Custom Shapes
            </div>
            <p style="margin-bottom: 10px; font-size: 14px; color: #a0a0d0;">
                Press Ctrl+Click to save current shape
            </p>
            
            <div class="save-section">
                <input type="text" id="shape-name" placeholder="Enter shape name">
                <button id="save-shape">Save</button>
            </div>
            
            <div class="saved-shapes" id="saved-shapes">
                <!-- Saved shapes will appear here -->
            </div>
        </div>
    </div>
    
    <div class="stats">
        <span id="particle-count">8000</span> Particles | 
        <span id="current-shape">Sphere</span>
    </div>
    
    <div class="notification" id="notification">Shape saved successfully!</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f0c29);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Camera position
        camera.position.z = 40;

        // Configuration
        const config = {
            particleCount: 8000,
            particleSize: 1.5,
            particleOpacity: 0.9,
            morphSpeed: 0.02,
            rotationSpeedX: 0.001,
            rotationSpeedY: 0.002,
            connectionDensity: 0.02,
            connectionWidth: 0.8,
            autoMorph: true,
            autoMorphDelay: 3000,
            baseColor: '#00aaff',
            highlightColor: '#ff00aa',
            particleType: 'circle',
            currentShape: 'Sphere',
            wireframe: false
        };

        // Particles
        let particles = new THREE.BufferGeometry();
        let positions = new Float32Array(config.particleCount * 3);
        let colors = new Float32Array(config.particleCount * 3);
        let sizes = new Float32Array(config.particleCount);
        let originalPositions = new Float32Array(config.particleCount * 3);
        let targetPositions = new Float32Array(config.particleCount * 3);

        // Store custom shapes
        let customShapes = {};
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            ] : [0, 0, 0];
        }

        // Create particles
        function initParticles() {
            const baseRgb = hexToRgb(config.baseColor);
            const highlightRgb = hexToRgb(config.highlightColor);
            
            for (let i = 0; i < config.particleCount; i++) {
                // Initial sphere positions
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 15 + Math.random() * 2;

                originalPositions[i * 3] = positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                originalPositions[i * 3 + 1] = positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                originalPositions[i * 3 + 2] = positions[i * 3 + 2] = radius * Math.cos(phi);

                // Color gradient with some highlights
                const mixFactor = Math.random();
                colors[i * 3] = baseRgb[0] * (1 - mixFactor) + highlightRgb[0] * mixFactor;
                colors[i * 3 + 1] = baseRgb[1] * (1 - mixFactor) + highlightRgb[1] * mixFactor;
                colors[i * 3 + 2] = baseRgb[2] * (1 - mixFactor) + highlightRgb[2] * mixFactor;

                sizes[i] = config.particleSize * (0.8 + Math.random() * 0.4);
                
                targetPositions[i * 3] = originalPositions[i * 3];
                targetPositions[i * 3 + 1] = originalPositions[i * 3 + 1];
                targetPositions[i * 3 + 2] = originalPositions[i * 3 + 2];
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        }

        // Create particle material based on type
        function createParticleMaterial() {
            let material;
            
            switch(config.particleType) {
                case 'circle':
                    material = new THREE.PointsMaterial({
                        size: config.particleSize,
                        vertexColors: true,
                        transparent: true,
                        opacity: config.particleOpacity,
                        blending: THREE.AdditiveBlending,
                        sizeAttenuation: true
                    });
                    break;
                    
                case 'square':
                    const squareCanvas = document.createElement('canvas');
                    squareCanvas.width = squareCanvas.height = 64;
                    const squareCtx = squareCanvas.getContext('2d');
                    squareCtx.fillStyle = 'white';
                    squareCtx.fillRect(0, 0, 64, 64);
                    
                    material = new THREE.PointsMaterial({
                        size: config.particleSize,
                        vertexColors: true,
                        transparent: true,
                        opacity: config.particleOpacity,
                        blending: THREE.AdditiveBlending,
                        sizeAttenuation: true,
                        map: new THREE.CanvasTexture(squareCanvas)
                    });
                    break;
                    
                case 'star':
                    const starCanvas = document.createElement('canvas');
                    starCanvas.width = starCanvas.height = 64;
                    const starCtx = starCanvas.getContext('2d');
                    starCtx.fillStyle = 'white';
                    drawStar(starCtx, 32, 32, 5, 28, 12);
                    
                    material = new THREE.PointsMaterial({
                        size: config.particleSize * 1.5,
                        vertexColors: true,
                        transparent: true,
                        opacity: config.particleOpacity,
                        blending: THREE.AdditiveBlending,
                        sizeAttenuation: true,
                        map: new THREE.CanvasTexture(starCanvas)
                    });
                    break;
                    
                case 'glow':
                    const glowCanvas = document.createElement('canvas');
                    glowCanvas.width = glowCanvas.height = 64;
                    const glowCtx = glowCanvas.getContext('2d');
                    const gradient = glowCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
                    gradient.addColorStop(0, 'rgba(255,255,255,1)');
                    gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                    gradient.addColorStop(1, 'rgba(255,255,255,0)');
                    glowCtx.fillStyle = gradient;
                    glowCtx.fillRect(0, 0, 64, 64);
                    
                    material = new THREE.PointsMaterial({
                        size: config.particleSize * 2,
                        vertexColors: true,
                        transparent: true,
                        opacity: config.particleOpacity,
                        blending: THREE.AdditiveBlending,
                        sizeAttenuation: true,
                        map: new THREE.CanvasTexture(glowCanvas)
                    });
                    break;
            }
            
            if (config.wireframe) {
                material.wireframe = true;
            }
            
            return material;
        }

        // Helper to draw a star
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        // Initialize particles
        initParticles();
        let particleMaterial = createParticleMaterial();
        let particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);

        // Connections
        const connections = [];
        const connectionMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0.3,
            linewidth: config.connectionWidth
        });

        function createConnections() {
            // Clear existing connections
            connections.forEach(conn => {
                scene.remove(conn.line);
                if (conn.sphere) scene.remove(conn.sphere);
            });
            connections.length = 0;

            // Create new connections
            const connectionCount = Math.floor(config.particleCount * config.connectionDensity);
            
            for (let i = 0; i < connectionCount; i++) {
                const startIdx = Math.floor(Math.random() * config.particleCount);
                const endIdx = Math.floor(Math.random() * config.particleCount);
                
                const startPos = new THREE.Vector3(
                    positions[startIdx * 3],
                    positions[startIdx * 3 + 1],
                    positions[startIdx * 3 + 2]
                );
                
                const endPos = new THREE.Vector3(
                    positions[endIdx * 3],
                    positions[endIdx * 3 + 1],
                    positions[endIdx * 3 + 2]
                );
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                const line = new THREE.Line(lineGeometry, connectionMaterial);
                scene.add(line);
                
                connections.push({ 
                    line, 
                    startIdx, 
                    endIdx, 
                    progress: Math.random(), 
                    speed: Math.random() * 0.01 
                });
            }
        }

        createConnections();

        // Shape generators - now with 100+ shapes organized by category
        const shapes = {
            // Basic 3D Shapes (20)
            'Sphere': (i, radius = 15) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return [
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                ];
            },
            'Cube': (i, size = 20) => {
                return [
                    (Math.random() - 0.5) * size,
                    (Math.random() - 0.5) * size,
                    (Math.random() - 0.5) * size
                ];
            },
            'Torus': (i, radius = 15, tube = 5) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 2;
                return [
                    (radius + tube * Math.cos(phi)) * Math.cos(theta),
                    (radius + tube * Math.cos(phi)) * Math.sin(theta),
                    tube * Math.sin(phi)
                ];
            },
            'Cylinder': (i, radius = 10, height = 30) => {
                const theta = Math.random() * Math.PI * 2;
                return [
                    radius * Math.cos(theta),
                    radius * Math.sin(theta),
                    height * (Math.random() - 0.5)
                ];
            },
            'Cone': (i, radius = 15, height = 30) => {
                const theta = Math.random() * Math.PI * 2;
                const r = radius * (1 - i / config.particleCount);
                return [
                    r * Math.cos(theta),
                    r * Math.sin(theta),
                    height * (i / config.particleCount - 0.5)
                ];
            },
            'Pyramid': (i, size = 25) => {
                const layerCount = 20;
                const layer = Math.floor(i / (config.particleCount / layerCount));
                const layerSize = size * (1 - layer / layerCount);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * layerSize;
                const height = size * (layer / layerCount - 0.5);
                return [
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance,
                    height
                ];
            },
            'Diamond': (i, size = 20) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = size * (0.5 + Math.abs(Math.cos(phi * 2)) * 0.5);
                return [
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                ];
            },
            'Octahedron': (i, size = 18) => {
                const vertices = [
                    [0, size, 0], [0, -size, 0], [size, 0, 0], 
                    [-size, 0, 0], [0, 0, size], [0, 0, -size]
                ];
                const vertex = vertices[Math.floor(Math.random() * vertices.length)];
                const noise = (Math.random() - 0.5) * 3;
                return [vertex[0] + noise, vertex[1] + noise, vertex[2] + noise];
            },
            'Dodecahedron': (i, size = 15) => {
                const phi = (1 + Math.sqrt(5)) / 2;
                const vertices = [
                    [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
                    [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
                    [0, 1/phi, phi], [0, 1/phi, -phi], [0, -1/phi, phi], [0, -1/phi, -phi],
                    [1/phi, phi, 0], [1/phi, -phi, 0], [-1/phi, phi, 0], [-1/phi, -phi, 0],
                    [phi, 0, 1/phi], [phi, 0, -1/phi], [-phi, 0, 1/phi], [-phi, 0, -1/phi]
                ];
                const vertex = vertices[Math.floor(Math.random() * vertices.length)];
                return [vertex[0] * size, vertex[1] * size, vertex[2] * size];
            },
            'Icosahedron': (i, size = 16) => {
                const phi = (1 + Math.sqrt(5)) / 2;
                const vertices = [
                    [0, 1, phi], [0, 1, -phi], [0, -1, phi], [0, -1, -phi],
                    [1, phi, 0], [1, -phi, 0], [-1, phi, 0], [-1, -phi, 0],
                    [phi, 0, 1], [phi, 0, -1], [-phi, 0, 1], [-phi, 0, -1]
                ];
                const vertex = vertices[Math.floor(Math.random() * vertices.length)];
                const noise = (Math.random() - 0.5) * 2;
                return [vertex[0] * size + noise, vertex[1] * size + noise, vertex[2] * size + noise];
            },
            'Tetrahedron': (i, size = 20) => {
                const vertices = [
                    [1, 1, 1], [1, -1, -1], [-1, 1, -1], [-1, -1, 1]
                ];
                const vertex = vertices[Math.floor(Math.random() * vertices.length)];
                const noise = (Math.random() - 0.5) * 4;
                return [vertex[0] * size + noise, vertex[1] * size + noise, vertex[2] * size + noise];
            },
            'Prism': (i, sides = 6, radius = 12, height = 25) => {
                const angle = (Math.floor(Math.random() * sides) / sides) * Math.PI * 2;
                const r = radius * (0.8 + Math.random() * 0.4);
                return [
                    r * Math.cos(angle),
                    r * Math.sin(angle),
                    height * (Math.random() - 0.5)
                ];
            },
            'Ellipsoid': (i, a = 20, b = 15, c = 10) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return [
                    a * Math.sin(phi) * Math.cos(theta),
                    b * Math.sin(phi) * Math.sin(theta),
                    c * Math.cos(phi)
                ];
            },
            'Capsule': (i, radius = 8, height = 20) => {
                const theta = Math.random() * Math.PI * 2;
                const z = height * (Math.random() - 0.5);
                const capRadius = Math.abs(z) > height/2 - radius ? 
                    Math.sqrt(radius * radius - Math.pow(Math.abs(z) - (height/2 - radius), 2)) : radius;
                return [
                    capRadius * Math.cos(theta),
                    capRadius * Math.sin(theta),
                    z
                ];
            },
            'Wedge': (i, width = 25, height = 20, depth = 15) => {
                const x = width * (Math.random() - 0.5);
                const y = height * (Math.random() - 0.5);
                const z = depth * Math.random() * (1 - Math.abs(x) / (width/2));
                return [x, y, z];
            },

            // Scientific Shapes (15)
            'DNA_Helix': (i, radius = 8, pitch = 0.5, height = 30) => {
                const t = (i / config.particleCount) * height;
                const angle = t * pitch * Math.PI * 2;
                const strand = Math.floor(Math.random() * 2);
                return [
                    radius * Math.cos(angle + strand * Math.PI),
                    radius * Math.sin(angle + strand * Math.PI),
                    t - height/2
                ];
            },
            'Atom': (i, coreRadius = 3, orbitRadius = 15) => {
                if (i < config.particleCount * 0.1) {
                    // Core particles
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    return [
                        coreRadius * Math.sin(phi) * Math.cos(theta),
                        coreRadius * Math.sin(phi) * Math.sin(theta),
                        coreRadius * Math.cos(phi)
                    ];
                } else {
                    // Orbital particles
                    const orbit = Math.floor(Math.random() * 3);
                    const angle = Math.random() * Math.PI * 2;
                    const r = orbitRadius * (1 + orbit * 0.3);
                    return [
                        r * Math.cos(angle),
                        r * Math.sin(angle) * Math.cos(orbit * Math.PI / 3),
                        r * Math.sin(angle) * Math.sin(orbit * Math.PI / 3)
                    ];
                }
            },
            'Molecule': (i, bondLength = 8) => {
                const atoms = [
                    [0, 0, 0], [bondLength, 0, 0], [0, bondLength, 0], 
                    [0, 0, bondLength], [-bondLength, 0, 0], [0, -bondLength, 0]
                ];
                const atom = atoms[Math.floor(Math.random() * atoms.length)];
                const noise = (Math.random() - 0.5) * 2;
                return [atom[0] + noise, atom[1] + noise, atom[2] + noise];
            },
            'Crystal_Lattice': (i, spacing = 6) => {
                const x = Math.floor(Math.random() * 8 - 4) * spacing;
                const y = Math.floor(Math.random() * 8 - 4) * spacing;
                const z = Math.floor(Math.random() * 8 - 4) * spacing;
                const noise = (Math.random() - 0.5) * 2;
                return [x + noise, y + noise, z + noise];
            },
            'Virus': (i, coreRadius = 8, spikeLength = 6) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const isSpike = Math.random() < 0.3;
                const radius = isSpike ? coreRadius + Math.random() * spikeLength : coreRadius;
                return [
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                ];
            },
            'Protein_Fold': (i, amplitude = 15, frequency = 3) => {
                const t = (i / config.particleCount) * Math.PI * 2 * frequency;
                const x = amplitude * Math.sin(t);
                const y = amplitude * Math.cos(t * 1.3) * 0.7;
                const z = amplitude * Math.sin(t * 0.7) * Math.cos(t * 2);
                return [x, y, z];
            },
            'Neuron': (i, bodyRadius = 5, axonLength = 25) => {
                if (i < config.particleCount * 0.2) {
                    // Cell body
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    return [
                        bodyRadius * Math.sin(phi) * Math.cos(theta),
                        bodyRadius * Math.sin(phi) * Math.sin(theta),
                        bodyRadius * Math.cos(phi)
                    ];
                } else {
                    // Dendrites and axon
                    const branch = Math.floor(Math.random() * 6);
                    const angle = (branch / 6) * Math.PI * 2;
                    const length = Math.random() * axonLength;
                    return [
                        length * Math.cos(angle) + (Math.random() - 0.5) * 3,
                        length * Math.sin(angle) + (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 10
                    ];
                }
            },
            'Galaxy': (i, armCount = 4, radius = 20) => {
                const arm = Math.floor(Math.random() * armCount);
                const armAngle = (arm / armCount) * Math.PI * 2;
                const distance = Math.random() * radius;
                const spiralAngle = armAngle + distance * 0.3;
                const thickness = (Math.random() - 0.5) * 3;
                return [
                    distance * Math.cos(spiralAngle),
                    distance * Math.sin(spiralAngle),
                    thickness
                ];
            },
            'Solar_System': (i, centerRadius = 2) => {
                if (i < config.particleCount * 0.05) {
                    // Sun
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    return [
                        centerRadius * Math.sin(phi) * Math.cos(theta),
                        centerRadius * Math.sin(phi) * Math.sin(theta),
                        centerRadius * Math.cos(phi)
                    ];
                } else {
                    // Planets and orbits
                    const orbit = Math.floor(Math.random() * 8) + 1;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = orbit * 3 + Math.random() * 2;
                    return [
                        radius * Math.cos(angle),
                        radius * Math.sin(angle),
                        (Math.random() - 0.5) * 2
                    ];
                }
            },
            'Quantum_Cloud': (i, radius = 18) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = radius * Math.pow(Math.random(), 0.3); // Quantum probability distribution
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            },
            'Magnetic_Field': (i, strength = 15) => {
                const t = (i / config.particleCount) * Math.PI * 4;
                const radius = strength * (0.5 + 0.5 * Math.sin(t * 3));
                return [
                    radius * Math.cos(t),
                    radius * Math.sin(t),
                    strength * Math.sin(t * 2) * 0.3
                ];
            },
            'Electron_Orbital': (i, radius = 12) => {
                const orbital = Math.floor(Math.random() * 3); // s, p, d orbitals
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                let r = radius;
                if (orbital === 1) r *= Math.abs(Math.cos(phi)); // p orbital
                if (orbital === 2) r *= Math.abs(Math.sin(phi) * Math.cos(2 * theta)); // d orbital
                
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            },
            'Fractal_Tree': (i, trunkHeight = 20, branches = 5) => {
                const level = Math.floor(Math.random() * 4);
                const branchAngle = (Math.random() * branches / branches) * Math.PI * 2;
                const height = trunkHeight * Math.pow(0.7, level);
                const radius = level * 2;
                return [
                    radius * Math.cos(branchAngle),
                    radius * Math.sin(branchAngle),
                    height * (Math.random() - 0.5)
                ];
            },
            'Cellular_Structure': (i, cellSize = 8) => {
                const cellX = Math.floor(Math.random() * 5 - 2);
                const cellY = Math.floor(Math.random() * 5 - 2);
                const cellZ = Math.floor(Math.random() * 3 - 1);
                return [
                    cellX * cellSize + (Math.random() - 0.5) * cellSize * 0.8,
                    cellY * cellSize + (Math.random() - 0.5) * cellSize * 0.8,
                    cellZ * cellSize + (Math.random() - 0.5) * cellSize * 0.8
                ];
            },

            // Organic Shapes (15)
            'Flower': (i, petalCount = 8, radius = 15) => {
                const angle = (Math.floor(Math.random() * petalCount) / petalCount) * Math.PI * 2;
                const petalRadius = radius * (0.7 + 0.3 * Math.sin(angle * petalCount));
                const distance = Math.random() * petalRadius;
                return [
                    distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    (Math.random() - 0.5) * 3
                ];
            },
            'Tree': (i, trunkRadius = 3, height = 25, crownRadius = 12) => {
                if (i < config.particleCount * 0.3) {
                    // Trunk
                    const angle = Math.random() * Math.PI * 2;
                    const r = trunkRadius * Math.random();
                    return [
                        r * Math.cos(angle),
                        r * Math.sin(angle),
                        height * (Math.random() - 1) * 0.4
                    ];
                } else {
                    // Crown
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = crownRadius * Math.random();
                    return [
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        height * 0.3 + r * Math.cos(phi) * 0.5
                    ];
                }
            },
            'Leaf': (i, length = 20, width = 12) => {
                const t = Math.random();
                const leafShape = Math.sin(t * Math.PI);
                const x = (t - 0.5) * length;
                const y = (Math.random() - 0.5) * width * leafShape;
                const z = (Math.random() - 0.5) * 2;
                return [x, y, z];
            },
            'Butterfly': (i, wingspan = 20, bodyLength = 15) => {
                const isBody = Math.random() < 0.2;
                if (isBody) {
                    return [
                        (Math.random() - 0.5) * 2,
                        bodyLength * (Math.random() - 0.5),
                        (Math.random() - 0.5) * 3
                    ];
                } else {
                    const side = Math.random() < 0.5 ? -1 : 1;
                    const wingX = side * wingspan * (0.3 + Math.random() * 0.7);
                    const wingY = bodyLength * (Math.random() - 0.3) * 0.6;
                    const wingZ = (Math.random() - 0.5) * 2;
                    return [wingX, wingY, wingZ];
                }
            },
            'Seashell': (i, radius = 12, coils = 3) => {
                const t = (i / config.particleCount) * coils * Math.PI * 2;
                const r = radius * (1 - i / config.particleCount);
                const height = 15 * (i / config.particleCount);
                return [
                    r * Math.cos(t),
                    r * Math.sin(t),
                    height - 7.5
                ];
            },
            'Coral': (i, branches = 8, height = 20) => {
                const branch = Math.floor(Math.random() * branches);
                const angle = (branch / branches) * Math.PI * 2;
                const distance = Math.random() * 12;
                const branchHeight = Math.random() * height;
                const noise = (Math.random() - 0.5) * 3;
                return [
                    distance * Math.cos(angle) + noise,
                    distance * Math.sin(angle) + noise,
                    branchHeight - height/2
                ];
            },
            'Mushroom': (i, capRadius = 12, stemHeight = 8, stemRadius = 2) => {
                if (i < config.particleCount * 0.7) {
                    // Cap
                    const theta = Math.random() * Math.PI * 2;
                    const r = capRadius * Math.sqrt(Math.random());
                    const capHeight = Math.sqrt(capRadius * capRadius - r * r) * 0.3;
                    return [
                        r * Math.cos(theta),
                        r * Math.sin(theta),
                        stemHeight + capHeight
                    ];
                } else {
                    // Stem
                    const theta = Math.random() * Math.PI * 2;
                    const r = stemRadius * Math.random();
                    return [
                        r * Math.cos(theta),
                        r * Math.sin(theta),
                        stemHeight * Math.random()
                    ];
                }
            },
            'Vine': (i, length = 30, amplitude = 8) => {
                const t = (i / config.particleCount) * length;
                const x = amplitude * Math.sin(t * 0.3) * Math.cos(t * 0.1);
                const y = amplitude * Math.cos(t * 0.3) * Math.sin(t * 0.1);
                const z = t - length/2;
                return [x, y, z];
            },
            'Feather': (i, length = 25, width = 8) => {
                const t = Math.random();
                const spine = length * (t - 0.5);
                const barbule = width * (Math.random() - 0.5) * (1 - Math.abs(t - 0.5) * 2);
                const flutter = (Math.random() - 0.5) * 2;
                return [barbule, spine, flutter];
            },
            'Antler': (i, mainLength = 20, branches = 4) => {
                const mainT = Math.random();
                const mainPos = mainLength * (mainT - 0.5);
                
                if (Math.random() < 0.7) {
                    // Main antler
                    return [
                        (Math.random() - 0.5) * 2,
                        mainPos,
                        mainPos * 0.3 + (Math.random() - 0.5) * 2
                    ];
                } else {
                    // Branches
                    const branchAngle = Math.random() * Math.PI * 2;
                    const branchLength = Math.random() * 8;
                    return [
                        branchLength * Math.cos(branchAngle),
                        mainPos,
                        mainPos * 0.3 + branchLength * Math.sin(branchAngle)
                    ];
                }
            },
            'Petal': (i, radius = 15, curve = 0.3) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                const petalCurve = Math.sin(distance / radius * Math.PI) * curve;
                return [
                    distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    petalCurve * radius
                ];
            },
            'Branch': (i, length = 25, splits = 3) => {
                const segment = Math.floor(Math.random() * splits);
                const segmentLength = length / splits;
                const angle = segment * Math.PI / 6;
                const distance = Math.random() * segmentLength;
                return [
                    distance * Math.sin(angle) + (Math.random() - 0.5) * 2,
                    distance * Math.cos(angle),
                    (Math.random() - 0.5) * 3
                ];
            },
            'Seed_Pod': (i, length = 18, segments = 6) => {
                const segment = Math.floor(Math.random() * segments);
                const segmentPos = (segment / segments) * length - length/2;
                const radius = 4 * Math.sin((segment / segments) * Math.PI);
                const angle = Math.random() * Math.PI * 2;
                return [
                    radius * Math.cos(angle),
                    segmentPos,
                    radius * Math.sin(angle)
                ];
            },
            'Root_System': (i, depth = 20, spread = 15) => {
                const rootLevel = Math.floor(Math.random() * 4);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * spread * (1 - rootLevel * 0.2);
                const rootDepth = -depth * Math.random() * (rootLevel + 1) / 4;
                return [
                    distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    rootDepth
                ];
            },

            // Mathematical Shapes (20)
            'Klein_Bottle': (i, radius = 12) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const x = (radius + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v)) * Math.cos(u);
                const y = (radius + Math.cos(u/2) * Math.sin(v) - Math.sin(u/2) * Math.sin(2*v)) * Math.sin(u);
                const z = Math.sin(u/2) * Math.sin(v) + Math.cos(u/2) * Math.sin(2*v);
                return [x * 0.8, y * 0.8, z * radius];
            },
            'Mobius_Strip': (i, radius = 15, width = 6) => {
                const u = Math.random() * Math.PI * 2;
                const v = (Math.random() - 0.5) * width;
                const x = (radius + v * Math.cos(u/2)) * Math.cos(u);
                const y = (radius + v * Math.cos(u/2)) * Math.sin(u);
                const z = v * Math.sin(u/2);
                return [x, y, z];
            },
            'Fibonacci_Spiral': (i, scale = 15) => {
                const n = i / config.particleCount * 1000;
                const angle = n * 2.39996; // Golden angle
                const radius = scale * Math.sqrt(n) / 10;
                return [
                    radius * Math.cos(angle),
                    radius * Math.sin(angle),
                    (Math.random() - 0.5) * 3
                ];
            },
            'Mandelbrot': (i, scale = 20, iterations = 10) => {
                const x = (Math.random() - 0.5) * 4;
                const y = (Math.random() - 0.5) * 4;
                let zx = 0, zy = 0;
                let iter = 0;
                
                while (zx*zx + zy*zy < 4 && iter < iterations) {
                    const temp = zx*zx - zy*zy + x;
                    zy = 2*zx*zy + y;
                    zx = temp;
                    iter++;
                }
                
                return [
                    x * scale,
                    y * scale,
                    (iter / iterations - 0.5) * scale
                ];
            },
            'Lorenz_Attractor': (i, scale = 0.5) => {
                // Simplified Lorenz attractor points
                const t = i / config.particleCount * 100;
                const x = 10 * (Math.sin(t * 0.1) - Math.cos(t * 0.07));
                const y = 28 * Math.sin(t * 0.08) - Math.cos(t * 0.12);
                const z = 8/3 * Math.sin(t * 0.09) + 2.67;
                return [x * scale, y * scale, z * scale];
            },
            'Hypercube': (i, size = 15) => {
                // 4D hypercube projected to 3D
                const coords = [];
                for (let j = 0; j < 4; j++) {
                    coords.push(Math.random() < 0.5 ? -size : size);
                }
                // Project 4D to 3D
                return [coords[0], coords[1], coords[2] + coords[3] * 0.5];
            },
            'Sine_Wave': (i, amplitude = 15, frequency = 2, length = 30) => {
                const x = (i / config.particleCount - 0.5) * length;
                const y = amplitude * Math.sin(x * frequency * Math.PI / length);
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Cosine_Wave': (i, amplitude = 15, frequency = 2, length = 30) => {
                const x = (i / config.particleCount - 0.5) * length;
                const y = amplitude * Math.cos(x * frequency * Math.PI / length);
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Parabola': (i, scale = 0.05, height = 25) => {
                const x = (Math.random() - 0.5) * height;
                const y = scale * x * x;
                const z = (Math.random() - 0.5) * 5;
                return [x, y - height/2, z];
            },
            'Hyperbola': (i, a = 10, b = 8, range = 20) => {
                const t = (Math.random() - 0.5) * range;
                const branch = Math.random() < 0.5 ? 1 : -1;
                const x = branch * a * Math.sqrt(1 + (t*t)/(b*b));
                const y = t;
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Ellipse': (i, a = 18, b = 12) => {
                const angle = Math.random() * Math.PI * 2;
                return [
                    a * Math.cos(angle),
                    b * Math.sin(angle),
                    (Math.random() - 0.5) * 3
                ];
            },
            'Lemniscate': (i, scale = 15) => {
                const t = Math.random() * Math.PI * 2;
                const x = scale * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                const y = scale * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Cardioid': (i, scale = 10) => {
                const t = Math.random() * Math.PI * 2;
                const x = scale * (2 * Math.cos(t) - Math.cos(2*t));
                const y = scale * (2 * Math.sin(t) - Math.sin(2*t));
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Astroid': (i, scale = 15) => {
                const t = Math.random() * Math.PI * 2;
                const x = scale * Math.pow(Math.cos(t), 3);
                const y = scale * Math.pow(Math.sin(t), 3);
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Cycloid': (i, radius = 8, cycles = 3) => {
                const t = (Math.random() * cycles) * Math.PI * 2;
                const x = radius * (t - Math.sin(t));
                const y = radius * (1 - Math.cos(t));
                const z = (Math.random() - 0.5) * 3;
                return [x - cycles * Math.PI * radius / 2, y - radius, z];
            },
            'Epicycloid': (i, R = 10, r = 3, cycles = 4) => {
                const t = (Math.random() * cycles) * Math.PI * 2;
                const x = (R + r) * Math.cos(t) - r * Math.cos((R + r) * t / r);
                const y = (R + r) * Math.sin(t) - r * Math.sin((R + r) * t / r);
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Hypocycloid': (i, R = 12, r = 4, cycles = 3) => {
                const t = (Math.random() * cycles) * Math.PI * 2;
                const x = (R - r) * Math.cos(t) + r * Math.cos((R - r) * t / r);
                const y = (R - r) * Math.sin(t) - r * Math.sin((R - r) * t / r);
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Rose_Curve': (i, amplitude = 15, petals = 5) => {
                const t = Math.random() * Math.PI * 2;
                const r = amplitude * Math.cos(petals * t);
                const x = r * Math.cos(t);
                const y = r * Math.sin(t);
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z];
            },
            'Archimedean_Spiral': (i, spacing = 2, turns = 5) => {
                const t = (i / config.particleCount) * turns * Math.PI * 2;
                const r = spacing * t / (Math.PI * 2);
                return [
                    r * Math.cos(t),
                    r * Math.sin(t),
                    (Math.random() - 0.5) * 3
                ];
            },
            'Logarithmic_Spiral': (i, a = 1, b = 0.2, turns = 3) => {
                const t = (i / config.particleCount) * turns * Math.PI * 2;
                const r = a * Math.exp(b * t);
                return [
                    r * Math.cos(t),
                    r * Math.sin(t),
                    (Math.random() - 0.5) * 3
                ];
            },

            // Structural Shapes (20)
            'Lattice': (i, spacing = 8, size = 5) => {
                const x = (Math.floor(Math.random() * size) - size/2) * spacing;
                const y = (Math.floor(Math.random() * size) - size/2) * spacing;
                const z = (Math.floor(Math.random() * size) - size/2) * spacing;
                return [x, y, z];
            },
            'Honeycomb': (i, cellSize = 6, layers = 4) => {
                const layer = Math.floor(Math.random() * layers);
                const cellsPerLayer = 19; // Hexagonal packing
                const cellIndex = Math.floor(Math.random() * cellsPerLayer);
                
                // Hexagonal grid coordinates
                const angle = (cellIndex / cellsPerLayer) * Math.PI * 2;
                const radius = cellSize * (1 + Math.floor(cellIndex / 6));
                
                return [
                    radius * Math.cos(angle),
                    radius * Math.sin(angle),
                    layer * cellSize - (layers * cellSize) / 2
                ];
            },
            'Bridge': (i, length = 30, height = 15, cables = 8) => {
                if (i < config.particleCount * 0.6) {
                    // Bridge deck
                    const x = (Math.random() - 0.5) * length;
                    const y = (Math.random() - 0.5) * 4;
                    const z = -height * 0.3;
                    return [x, y, z];
                } else {
                    // Cables and towers
                    const tower = Math.random() < 0.5 ? -1 : 1;
                    const towerX = tower * length * 0.3;
                    const cableHeight = height * Math.random();
                    return [
                        towerX + (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 3,
                        cableHeight - height * 0.3
                    ];
                }
            },
            'Skyscraper': (i, width = 8, depth = 8, height = 35, floors = 20) => {
                const floor = Math.floor(Math.random() * floors);
                const floorHeight = height / floors;
                return [
                    (Math.random() - 0.5) * width,
                    (Math.random() - 0.5) * depth,
                    floor * floorHeight - height/2
                ];
            },
            'Dome': (i, radius = 18, height = 12) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI / 2; // Only upper hemisphere
                const r = radius * Math.sin(phi);
                return [
                    r * Math.cos(theta),
                    r * Math.sin(theta),
                    height * Math.cos(phi) - height/2
                ];
            },
            'Arch': (i, width = 25, height = 20, thickness = 4) => {
                const angle = Math.random() * Math.PI;
                const radius = width / 2;
                const archRadius = radius - thickness * Math.random();
                return [
                    archRadius * Math.cos(angle),
                    (Math.random() - 0.5) * thickness,
                    archRadius * Math.sin(angle) - height/2
                ];
            },
            'Spiral_Staircase': (i, radius = 10, height = 30, turns = 3) => {
                const t = (i / config.particleCount) * turns * Math.PI * 2;
                const stepHeight = height / (config.particleCount / 50);
                return [
                    radius * Math.cos(t) + (Math.random() - 0.5) * 2,
                    radius * Math.sin(t) + (Math.random() - 0.5) * 2,
                    (i / config.particleCount) * height - height/2
                ];
            },
            'Truss': (i, length = 30, height = 8, segments = 10) => {
                const segment = Math.floor(Math.random() * segments);
                const segmentLength = length / segments;
                const x = segment * segmentLength - length/2;
                
                // Triangular truss pattern
                const isTop = Math.random() < 0.5;
                const y = (Math.random() - 0.5) * 2;
                const z = isTop ? height/2 : -height/2;
                
                return [x, y, z];
            },
            'Geodesic': (i, radius = 16, frequency = 2) => {
                // Simplified geodesic dome
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI / 2;
                
                // Add geodesic triangulation effect
                const triangleSize = Math.PI / (frequency * 3);
                const snapTheta = Math.floor(theta / triangleSize) * triangleSize;
                const snapPhi = Math.floor(phi / triangleSize) * triangleSize;
                
                return [
                    radius * Math.sin(snapPhi) * Math.cos(snapTheta),
                    radius * Math.sin(snapPhi) * Math.sin(snapTheta),
                    radius * Math.cos(snapPhi) - radius/2
                ];
            },
            'Suspension_Bridge': (i, span = 40, height = 20, towers = 2) => {
                if (i < config.particleCount * 0.1) {
                    // Towers
                    const tower = Math.floor(Math.random() * towers);
                    const towerX = (tower - 0.5) * span * 0.6;
                    return [
                        towerX,
                        (Math.random() - 0.5) * 3,
                        height * Math.random() - height/2
                    ];
                } else if (i < config.particleCount * 0.4) {
                    // Main cables
                    const x = (Math.random() - 0.5) * span;
                    const sag = height * 0.3 * (1 - 4 * Math.pow(x/span, 2));
                    return [x, (Math.random() - 0.5) * 2, sag];
                } else {
                    // Deck
                    return [
                        (Math.random() - 0.5) * span,
                        (Math.random() - 0.5) * 6,
                        -height * 0.4
                    ];
                }
            },
            'Pagoda': (i, levels = 5, baseSize = 15, height = 25) => {
                const level = Math.floor(Math.random() * levels);
                const levelHeight = height / levels;
                const levelSize = baseSize * (1 - level / (levels + 1));
                
                return [
                    (Math.random() - 0.5) * levelSize,
                    (Math.random() - 0.5) * levelSize,
                    level * levelHeight - height/2
                ];
            },
            'Windmill': (i, bladeLength = 20, towerHeight = 15, blades = 3) => {
                if (i < config.particleCount * 0.3) {
                    // Tower
                    return [
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        towerHeight * Math.random() - towerHeight/2
                    ];
                } else {
                    // Blades
                    const blade = Math.floor(Math.random() * blades);
                    const angle = (blade / blades) * Math.PI * 2;
                    const distance = Math.random() * bladeLength;
                    return [
                        distance * Math.cos(angle),
                        distance * Math.sin(angle),
                        towerHeight * 0.3
                    ];
                }
            },
            'Lighthouse': (i, radius = 6, height = 30, beamRange = 25) => {
                if (i < config.particleCount * 0.4) {
                    // Tower
                    const angle = Math.random() * Math.PI * 2;
                    const r = radius * (1 - Math.random() * 0.3);
                    return [
                        r * Math.cos(angle),
                        r * Math.sin(angle),
                        height * Math.random() - height/2
                    ];
                } else {
                    // Light beam
                    const beamAngle = Math.random() * Math.PI * 2;
                    const beamDistance = Math.random() * beamRange;
                    return [
                        beamDistance * Math.cos(beamAngle),
                        beamDistance * Math.sin(beamAngle),
                        height * 0.4 + (Math.random() - 0.5) * 3
                    ];
                }
            },
            'Castle': (i, wallHeight = 20, towerHeight = 30, courtyard = 15) => {
                const structure = Math.floor(Math.random() * 4);
                
                switch(structure) {
                    case 0: // Walls
                        const wall = Math.floor(Math.random() * 4);
                        const wallPos = (wall < 2) ? 
                            [(wall === 0 ? -1 : 1) * courtyard/2, (Math.random() - 0.5) * courtyard] :
                            [(Math.random() - 0.5) * courtyard, (wall === 2 ? -1 : 1) * courtyard/2];
                        return [wallPos[0], wallPos[1], wallHeight * Math.random() - wallHeight/2];
                        
                    case 1: // Towers
                        const corner = Math.floor(Math.random() * 4);
                        const cornerX = (corner % 2 === 0 ? -1 : 1) * courtyard/2;
                        const cornerY = (corner < 2 ? -1 : 1) * courtyard/2;
                        return [
                            cornerX + (Math.random() - 0.5) * 4,
                            cornerY + (Math.random() - 0.5) * 4,
                            towerHeight * Math.random() - towerHeight/2
                        ];
                        
                    default: // Courtyard
                        return [
                            (Math.random() - 0.5) * courtyard * 0.8,
                            (Math.random() - 0.5) * courtyard * 0.8,
                            -wallHeight/2 + (Math.random() - 0.5) * 2
                        ];
                }
            },
            'Pyramid_Complex': (i, pyramids = 3, baseSize = 20, height = 25) => {
                const pyramid = Math.floor(Math.random() * pyramids);
                const pyramidX = (pyramid - 1) * baseSize * 1.5;
                
                const layerCount = 15;
                const layer = Math.floor(Math.random() * layerCount);
                const layerSize = baseSize * (1 - layer / layerCount);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * layerSize;
                
                return [
                    pyramidX + Math.cos(angle) * distance,
                    Math.sin(angle) * distance,
                    height * (layer / layerCount - 0.5)
                ];
            },
            'Colosseum': (i, outerRadius = 20, innerRadius = 12, height = 15, levels = 3) => {
                const level = Math.floor(Math.random() * levels);
                const levelHeight = height / levels;
                const angle = Math.random() * Math.PI * 2;
                
                // Alternating between outer wall and inner arena
                const isWall = Math.random() < 0.7;
                const radius = isWall ? 
                    outerRadius - Math.random() * 3 : 
                    innerRadius * Math.random();
                
                return [
                    radius * Math.cos(angle),
                    radius * Math.sin(angle),
                    level * levelHeight - height/2
                ];
            },
            'Space_Station': (i, ringRadius = 18, hubRadius = 6, spokeCount = 6) => {
                const structure = Math.floor(Math.random() * 3);
                
                switch(structure) {
                    case 0: // Ring
                        const ringAngle = Math.random() * Math.PI * 2;
                        return [
                            ringRadius * Math.cos(ringAngle) + (Math.random() - 0.5) * 2,
                            ringRadius * Math.sin(ringAngle) + (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 4
                        ];
                        
                    case 1: // Hub
                        const hubAngle = Math.random() * Math.PI * 2;
                        const hubR = hubRadius * Math.random();
                        return [
                            hubR * Math.cos(hubAngle),
                            hubR * Math.sin(hubAngle),
                            (Math.random() - 0.5) * 8
                        ];
                        
                    default: // Spokes
                        const spoke = Math.floor(Math.random() * spokeCount);
                        const spokeAngle = (spoke / spokeCount) * Math.PI * 2;
                        const spokeDistance = hubRadius + Math.random() * (ringRadius - hubRadius);
                        return [
                            spokeDistance * Math.cos(spokeAngle),
                            spokeDistance * Math.sin(spokeAngle),
                            (Math.random() - 0.5) * 2
                        ];
                }
            },
            'Aqueduct': (i, length = 40, height = 20, arches = 8) => {
                const archIndex = Math.floor(Math.random() * arches);
                const archSpacing = length / arches;
                const archCenter = archIndex * archSpacing - length/2;
                
                // Arch structure
                const angle = Math.random() * Math.PI;
                const archRadius = archSpacing * 0.4;
                const archHeight = height * 0.6;
                
                return [
                    archCenter + archRadius * Math.cos(angle),
                    (Math.random() - 0.5) * 4,
                    archRadius * Math.sin(angle) - height/2 + archHeight
                ];
            },
            'Observatory': (i, domeRadius = 15, baseHeight = 8, telescopeLength = 12) => {
                if (i < config.particleCount * 0.6) {
                    // Dome
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI / 2;
                    return [
                        domeRadius * Math.sin(phi) * Math.cos(theta),
                        domeRadius * Math.sin(phi) * Math.sin(theta),
                        domeRadius * Math.cos(phi) + baseHeight/2
                    ];
                } else if (i < config.particleCount * 0.8) {
                    // Base
                    const angle = Math.random() * Math.PI * 2;
                    const r = domeRadius * Math.random();
                    return [
                        r * Math.cos(angle),
                        r * Math.sin(angle),
                        baseHeight * Math.random() - baseHeight/2
                    ];
                } else {
                    // Telescope
                    const telescopeAngle = Math.PI / 4; // 45 degree angle
                    const distance = Math.random() * telescopeLength;
                    return [
                        distance * Math.cos(telescopeAngle),
                        (Math.random() - 0.5) * 2,
                        distance * Math.sin(telescopeAngle) + baseHeight/2
                    ];
                }
            }
                return [
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                ];
            },
            'DoublePyramid': (i, size = 25) => {
                const layerCount = 20;
                const layer = Math.floor(i / (config.particleCount / layerCount));
                const layerSize = size * (1 - Math.abs(layer - layerCount/2) / (layerCount/2));
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * layerSize;
                const height = size * (layer / layerCount - 0.5);
                return [
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance,
                    height
                ];
            },
            'SphericalShell': (i, radius = 15, thickness = 3) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = radius + (Math.random() - 0.5) * thickness;
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            },
            'BoxFrame': (i, size = 20) => {
                const edge = Math.floor(i / (config.particleCount / 12)) % 12;
                const pos = i % (config.particleCount / 12) / (config.particleCount / 12);
                
                // Define the 12 edges of a cube
                const edges = [
                    // Bottom face
                    [0, 0, 0, size/2, 0, 0],
                    [size/2, 0, 0, size/2, 0, size/2],
                    [size/2, 0, size/2, 0, 0, size/2],
                    [0, 0, size/2, 0, 0, 0],
                    // Top face
                    [0, size/2, 0, size/2, size/2, 0],
                    [size/2, size/2, 0, size/2, size/2, size/2],
                    [size/2, size/2, size/2, 0, size/2, size/2],
                    [0, size/2, size/2, 0, size/2, 0],
                    // Vertical edges
                    [0, 0, 0, 0, size/2, 0],
                    [size/2, 0, 0, size/2, size/2, 0],
                    [size/2, 0, size/2, size/2, size/2, size/2],
                    [0, 0, size/2, 0, size/2, size/2]
                ];
                
                const [x1, y1, z1, x2, y2, z2] = edges[edge];
                return [
                    (x1 + (x2 - x1) * pos) * (Math.random() > 0.5 ? 1 : -1),
                    (y1 + (y2 - y1) * pos) * (Math.random() > 0.5 ? 1 : -1),
                    (z1 + (z2 - z1) * pos) * (Math.random() > 0.5 ? 1 : -1)
                ];
            },
            'SpikySphere': (i, radius = 15, spikes = 20) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const spikeFactor = 1 + 0.3 * Math.sin(phi * spikes);
                return [
                    radius * spikeFactor * Math.sin(phi) * Math.cos(theta),
                    radius * spikeFactor * Math.sin(phi) * Math.sin(theta),
                    radius * spikeFactor * Math.cos(phi)
                ];
            },
            'WavySphere': (i, radius = 15, waves = 5) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const waveFactor = 1 + 0.2 * Math.sin(theta * waves) * Math.sin(phi * waves);
                return [
                    radius * waveFactor * Math.sin(phi) * Math.cos(theta),
                    radius * waveFactor * Math.sin(phi) * Math.sin(theta),
                    radius * waveFactor * Math.cos(phi)
                ];
            },
            'TwistedTorus': (i, radius = 15, tube = 5, twists = 3) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 2;
                const twistOffset = Math.sin(phi * twists) * 0.5;
                return [
                    (radius + tube * Math.cos(phi + twistOffset)) * Math.cos(theta),
                    (radius + tube * Math.cos(phi + twistOffset)) * Math.sin(theta),
                    tube * Math.sin(phi + twistOffset)
                ];
            },
            'LayeredSphere': (i, radius = 15, layers = 5) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const layer = Math.floor(i / (config.particleCount / layers)) % layers;
                const r = radius * (0.2 + 0.8 * layer / (layers - 1));
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            },
            'HollowCube': (i, size = 20, thickness = 3) => {
                // Randomly select one of the 6 faces
                const face = Math.floor(i / (config.particleCount / 6)) % 6;
                const pos = i % (config.particleCount / 6) / (config.particleCount / 6);
                
                // Define the 6 faces with random positions within thickness
                const offset = (Math.random() - 0.5) * thickness;
                
                switch(face) {
                    case 0: return [size/2, (pos - 0.5) * size, (Math.random() - 0.5) * size]; // +X
                    case 1: return [-size/2, (pos - 0.5) * size, (Math.random() - 0.5) * size]; // -X
                    case 2: return [(pos - 0.5) * size, size/2, (Math.random() - 0.5) * size]; // +Y
                    case 3: return [(pos - 0.5) * size, -size/2, (Math.random() - 0.5) * size]; // -Y
                    case 4: return [(Math.random() - 0.5) * size, (pos - 0.5) * size, size/2]; // +Z
                    case 5: return [(Math.random() - 0.5) * size, (pos - 0.5) * size, -size/2]; // -Z
                }
            },
            'SpiralStaircase': (i, radius = 15, height = 30, turns = 3) => {
                const t = i / config.particleCount * Math.PI * 2 * turns;
                const r = radius * (0.7 + 0.3 * Math.sin(t * 5));
                return [
                    r * Math.cos(t),
                    r * Math.sin(t),
                    height * (i / config.particleCount - 0.5)
                ];
            },
            'TwistedColumn': (i, radius = 10, height = 30, twists = 5) => {
                const t = i / config.particleCount * Math.PI * 2 * twists;
                const r = radius * (0.8 + 0.2 * Math.sin(t * 3));
                return [
                    r * Math.cos(t),
                    r * Math.sin(t),
                    height * (i / config.particleCount - 0.5)
                ];
            },
            'FractalCube': (i, size = 20, iterations = 3) => {
                // Simple fractal cube pattern
                let x = (Math.random() - 0.5) * size;
                let y = (Math.random() - 0.5) * size;
                let z = (Math.random() - 0.5) * size;
                
                for (let j = 0; j < iterations; j++) {
                    if (Math.random() > 0.5) x *= 0.5;
                    if (Math.random() > 0.5) y *= 0.5;
                    if (Math.random() > 0.5) z *= 0.5;
                }
                
                return [x, y, z];
            },
            'MengerSponge': (i, size = 20, iterations = 2) => {
                // Simplified approximation of Menger sponge
                let x = (Math.random() - 0.5) * size;
                let y = (Math.random() - 0.5) * size;
                let z = (Math.random() - 0.5) * size;
                
                for (let j = 0; j < iterations; j++) {
                    const scale = size / Math.pow(3, j+1);
                    if (Math.abs(x) < scale && Math.abs(y) < scale && Math.abs(z) < scale) {
                        // Skip the center cube
                        x = (Math.random() - 0.5) * size;
                        y = (Math.random() - 0.5) * size;
                        z = (Math.random() - 0.5) * size;
                        j = -1; // Restart iteration
                    }
                }
                
                return [x, y, z];
            },
            'Tetrahedron': (i, size = 20) => {
                // Points on a tetrahedron surface
                const face = Math.floor(i / (config.particleCount / 4)) % 4;
                const u = Math.random();
                const v = Math.random();
                
                // Vertices of a tetrahedron
                const vertices = [
                    [1, 1, 1],
                    [1, -1, -1],
                    [-1, 1, -1],
                    [-1, -1, 1]
                ];
                
                // Generate random point on the selected face
                let a, b, c;
                if (face === 0) { a = vertices[0]; b = vertices[1]; c = vertices[2]; }
                else if (face === 1) { a = vertices[0]; b = vertices[1]; c = vertices[3]; }
                else if (face === 2) { a = vertices[0]; b = vertices[2]; c = vertices[3]; }
                else { a = vertices[1]; b = vertices[2]; c = vertices[3]; }
                
                if (u + v > 1) {
                    u = 1 - u;
                    v = 1 - v;
                }
                
                const w = 1 - u - v;
                
                return [
                    size * 0.5 * (a[0] * u + b[0] * v + c[0] * w),
                    size * 0.5 * (a[1] * u + b[1] * v + c[1] * w),
                    size * 0.5 * (a[2] * u + b[2] * v + c[2] * w)
                ];
            },

            // Scientific Shapes (20)
            'Atom': (i, radius = 18) => {
                const orbit = Math.floor(i / (config.particleCount / 3)) % 3;
                const angle = Math.random() * Math.PI * 2;
                const orbitRadius = [radius * 0.4, radius * 0.7, radius][orbit];
                const orbitPlane = [0, 1, 2][orbit];
                const pos = [
                    orbitRadius * Math.cos(angle),
                    orbitRadius * Math.sin(angle),
                    (Math.random() - 0.5) * 5
                ];
                // Rotate to different planes
                if (orbitPlane === 1) return [pos[0], pos[2], pos[1]];
                if (orbitPlane === 2) return [pos[2], pos[1], pos[0]];
                return pos;
            },
            'DNA': (i, radius = 12, height = 30) => {
                const t = i / config.particleCount * Math.PI * 16;
                const strand = i % 2;
                const phase = strand * Math.PI;
                return [
                    radius * Math.cos(t + phase),
                    radius * Math.sin(t + phase),
                    height * (i / config.particleCount - 0.5)
                ];
            },
            'Molecule': (i, radius = 15) => {
                const atoms = 6;
                const atom = Math.floor(i / (config.particleCount / atoms)) % atoms;
                const angle = atom * Math.PI * 2 / atoms;
                const bondLength = radius * 0.6;
                return [
                    bondLength * Math.cos(angle) + (Math.random() - 0.5) * radius * 0.3,
                    bondLength * Math.sin(angle) + (Math.random() - 0.5) * radius * 0.3,
                    (Math.random() - 0.5) * radius * 0.3
                ];
            },
            'SolarSystem': (i, radius = 20) => {
                const planets = 8;
                const planet = Math.floor(i / (config.particleCount / planets)) % planets;
                const distance = radius * (0.2 + 0.8 * planet / planets);
                const angle = Math.random() * Math.PI * 2;
                const z = (Math.random() - 0.5) * radius * 0.1;
                return [
                    distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    z
                ];
            },
            'Galaxy': (i, radius = 20) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 2) * radius;
                const z = (Math.random() - 0.5) * radius * 0.2;
                return [
                    distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    z * (1 + Math.sin(angle * 5) * 0.5)
                ];
            },
            'SpiralGalaxy': (i, radius = 20, arms = 3) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 2) * radius;
                const armAngle = angle + Math.sin(angle * arms) * 0.5;
                const z = (Math.random() - 0.5) * radius * 0.2;
                return [
                    distance * Math.cos(armAngle),
                    distance * Math.sin(armAngle),
                    z
                ];
            },
            'BlackHole': (i, radius = 20) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 3) * radius;
                const z = (Math.random() - 0.5) * radius * 0.1;
                const spiral = Math.atan2(0.3, distance / radius) * 0.5;
                return [
                    distance * Math.cos(angle + spiral),
                    distance * Math.sin(angle + spiral),
                    z
                ];
            },
            'Nebula': (i, radius = 25) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 0.7) * radius;
                const z = (Math.random() - 0.5) * radius * 0.5;
                const turbulence = Math.sin(angle * 5) * 0.3;
                return [
                    distance * Math.cos(angle + turbulence),
                    distance * Math.sin(angle + turbulence),
                    z * (1 + Math.sin(angle * 3) * 0.3)
                ];
            },
            'QuantumOrbitals': (i, radius = 18) => {
                const orbital = Math.floor(i / (config.particleCount / 4)) % 4;
                const angle = Math.random() * Math.PI * 2;
                const orbitalRadius = radius * (0.3 + 0.2 * orbital);
                const lobes = [1, 2, 3, 4][orbital];
                const lobeFactor = Math.abs(Math.sin(angle * lobes));
                const r = orbitalRadius * (0.7 + 0.3 * lobeFactor);
                const z = (Math.random() - 0.5) * radius * 0.2;
                return [
                    r * Math.cos(angle),
                    r * Math.sin(angle),
                    z
                ];
            },
            'ParticleAccelerator': (i, radius = 15, length = 40) => {
                const t = i / config.particleCount * Math.PI * 8;
                const r = radius * (0.8 + 0.2 * Math.sin(t * 3));
                return [
                    r * Math.cos(t),
                    r * Math.sin(t),
                    length * (i / config.particleCount - 0.5)
                ];
            },
            'CrystalLattice': (i, size = 20) => {
                const gridSize = Math.cbrt(config.particleCount);
                const x = Math.floor(i / (gridSize * gridSize));
                const y = Math.floor((i % (gridSize * gridSize)) / gridSize);
                const z = i % gridSize;
                return [
                    size * (x / gridSize - 0.5),
                    size * (y / gridSize - 0.5),
                    size * (z / gridSize - 0.5)
                ];
            },
            'FCC_Lattice': (i, size = 20) => {
                // Face-centered cubic lattice
                const cells = 5;
                const cellSize = size / cells;
                const cell = Math.floor(i / (config.particleCount / (cells * cells * cells * 4)));
                const posInCell = i % (config.particleCount / (cells * cells * cells * 4));
                
                const xCell = Math.floor(cell / (cells * cells));
                const yCell = Math.floor((cell % (cells * cells)) / cells);
                const zCell = cell % cells;
                
                const basePositions = [
                    [0, 0, 0],
                    [0.5, 0.5, 0],
                    [0.5, 0, 0.5],
                    [0, 0.5, 0.5]
                ];
                
                const [bx, by, bz] = basePositions[posInCell % 4];
                
                return [
                    size * ((xCell + bx) / cells - 0.5),
                    size * ((yCell + by) / cells - 0.5),
                    size * ((zCell + bz) / cells - 0.5)
                ];
            },
            'BCC_Lattice': (i, size = 20) => {
                // Body-centered cubic lattice
                const cells = 5;
                const cellSize = size / cells;
                const cell = Math.floor(i / (config.particleCount / (cells * cells * cells * 2)));
                const posInCell = i % (config.particleCount / (cells * cells * cells * 2));
                
                const xCell = Math.floor(cell / (cells * cells));
                const yCell = Math.floor((cell % (cells * cells)) / cells);
                const zCell = cell % cells;
                
                const basePositions = [
                    [0, 0, 0],
                    [0.5, 0.5, 0.5]
                ];
                
                const [bx, by, bz] = basePositions[posInCell % 2];
                
                return [
                    size * ((xCell + bx) / cells - 0.5),
                    size * ((yCell + by) / cells - 0.5),
                    size * ((zCell + bz) / cells - 0.5)
                ];
            },
            'GrapheneSheet': (i, size = 25) => {
                // Hexagonal lattice like graphene
                const rows = Math.sqrt(config.particleCount / 2);
                const row = Math.floor(i / (config.particleCount / rows));
                const col = i % (config.particleCount / rows);
                
                const xSpacing = size * 1.5 / rows;
                const ySpacing = size * Math.sqrt(3) / rows;
                
                const x = (col - rows/2) * xSpacing;
                const y = (row - rows/2) * ySpacing + (col % 2) * ySpacing * 0.5;
                
                return [x, y, (Math.random() - 0.5) * size * 0.1];
            },
            'CarbonNanotube': (i, radius = 10, length = 30) => {
                const t = i / config.particleCount * Math.PI * 2 * 10;
                const row = Math.floor(i / (config.particleCount / 10));
                const z = length * (row / 10 - 0.5);
                const hexOffset = row % 2 === 0 ? 0 : Math.PI / 6;
                return [
                    radius * Math.cos(t + hexOffset),
                    radius * Math.sin(t + hexOffset),
                    z
                ];
            },
            'SuperconductorVortex': (i, radius = 15) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 0.5) * radius;
                const vortex = Math.atan2(0.2, distance / radius) * 2;
                return [
                    distance * Math.cos(angle + vortex),
                    distance * Math.sin(angle + vortex),
                    (Math.random() - 0.5) * radius * 0.2
                ];
            },
            'MagneticField': (i, radius = 20) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 0.7) * radius;
                const fieldLines = Math.floor(i / (config.particleCount / 5)) % 5;
                const z = radius * (fieldLines / 5 - 0.5) * 0.8;
                const twist = z * 0.2;
                return [
                    distance * Math.cos(angle + twist),
                    distance * Math.sin(angle + twist),
                    z
                ];
            },
            'QuantumFoam': (i, size = 25) => {
                // Chaotic quantum foam-like structure
                const x = (Math.random() - 0.5) * size;
                const y = (Math.random() - 0.5) * size;
                const z = (Math.random() - 0.5) * size;
                const turbulence = 0.3;
                return [
                    x + turbulence * Math.sin(y * 2) * Math.cos(z * 3),
                    y + turbulence * Math.sin(z * 2) * Math.cos(x * 3),
                    z + turbulence * Math.sin(x * 2) * Math.cos(y * 3)
                ];
            },
            'HiggsField': (i, radius = 20) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 0.8) * radius;
                const excitation = Math.sin(distance * 2) * 0.3;
                return [
                    distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    excitation * radius * 0.5
                ];
            },
            'StringTheory': (i, size = 25) => {
                // Vibrating string-like particles
                const t = i / config.particleCount * Math.PI * 10;
                const strand = i % 5;
                const vibration = Math.sin(t * 3) * 0.5;
                return [
                    size * 0.3 * Math.cos(t + strand * Math.PI * 0.4),
                    size * 0.3 * Math.sin(t + strand * Math.PI * 0.4),
                    size * (strand / 5 - 0.5) + vibration
                ];
            },

            // Organic Shapes (20)
            'Heart': (i, size = 15) => {
                const t = i / config.particleCount * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                return [
                    x * size * 0.04,
                    -y * size * 0.04,
                    (Math.random() - 0.5) * size * 0.5
                ];
            },
            'Flower': (i, radius = 15, petals = 6) => {
                const angle = i / config.particleCount * Math.PI * 2;
                const petalFactor = 1 + 0.3 * Math.sin(angle * petals);
                return [
                    radius * petalFactor * Math.cos(angle),
                    radius * petalFactor * Math.sin(angle),
                    (Math.random() - 0.5) * radius * 0.2
                ];
            },
            'Tree': (i, size = 20) => {
                const branch = Math.floor(i / (config.particleCount / 5));
                const posInBranch = (i % (config.particleCount / 5)) / (config.particleCount / 5);
                const angle = branch * Math.PI * 0.4;
                const length = size * (1 - posInBranch * 0.8);
                const width = size * 0.1 * (1 - posInBranch);
                return [
                    Math.cos(angle) * length,
                    Math.sin(angle) * length,
                    (Math.random() - 0.5) * width
                ];
            },
            'FractalTree': (i, size = 20) => {
                const branch = Math.floor(i / (config.particleCount / 5));
                const posInBranch = (i % (config.particleCount / 5)) / (config.particleCount / 5);
                const angle = branch * Math.PI * 0.4;
                const length = size * (1 - posInBranch * 0.8);
                const width = size * 0.1 * (1 - posInBranch);
                const subBranch = branch % 3;
                const subAngle = subBranch * Math.PI * 0.2;
                return [
                    Math.cos(angle + subAngle) * length,
                    Math.sin(angle + subAngle) * length,
                    (Math.random() - 0.5) * width
                ];
            },
            'Leaf': (i, size = 15) => {
                const t = i / config.particleCount * Math.PI * 2;
                const x = size * 0.5 * Math.cos(t);
                const y = size * Math.sin(t) * (0.3 + 0.7 * Math.abs(Math.cos(t)));
                return [
                    x,
                    y,
                    (Math.random() - 0.5) * size * 0.2
                ];
            },
            'DNA_Strand': (i, radius = 12, height = 30) => {
                const t = i / config.particleCount * Math.PI * 16;
                const strand = i % 2;
                const phase = strand * Math.PI;
                const basePair = Math.floor(i / (config.particleCount / 20)) % 20;
                const z = height * (basePair / 20 - 0.5);
                return [
                    radius * Math.cos(t + phase),
                    radius * Math.sin(t + phase),
                    z
                ];
            },
            'Neuron': (i, size = 20) => {
                const branch = Math.floor(i / (config.particleCount / 10));
                const posInBranch = (i % (config.particleCount / 10)) / (config.particleCount / 10);
                const angle = branch * Math.PI * 0.2;
                const length = size * (0.2 + 0.8 * posInBranch);
                const width = size * 0.1 * (1 - posInBranch);
                return [
                    Math.cos(angle) * length,
                    Math.sin(angle) * length,
                    (Math.random() - 0.5) * width
                ];
            },
            'BloodVessels': (i, radius = 15) => {
                const branch = Math.floor(i / (config.particleCount / 5));
                const posInBranch = (i % (config.particleCount / 5)) / (config.particleCount / 5);
                const angle = branch * Math.PI * 0.4;
                const length = radius * (0.3 + 0.7 * posInBranch);
                const width = radius * 0.1 * (1 - posInBranch);
                const pulse = Math.sin(posInBranch * Math.PI * 3) * 0.3;
                return [
                    Math.cos(angle + pulse) * length,
                    Math.sin(angle + pulse) * length,
                    (Math.random() - 0.5) * width
                ];
            },
            'Lungs': (i, size = 20) => {
                const side = i < config.particleCount / 2 ? -1 : 1;
                const pos = (i % (config.particleCount / 2)) / (config.particleCount / 2);
                const angle = pos * Math.PI * 2;
                const radius = size * (0.3 + 0.7 * Math.sin(pos * Math.PI));
                return [
                    side * (size * 0.4 + radius * Math.cos(angle)),
                    radius * Math.sin(angle),
                    (Math.random() - 0.5) * size * 0.3
                ];
            },
            'Brain': (i, size = 20) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const fold = Math.sin(phi * 10) * 0.3;
                return [
                    size * (0.8 + fold) * Math.sin(phi) * Math.cos(theta),
                    size * (0.8 + fold) * Math.sin(phi) * Math.sin(theta),
                    size * Math.cos(phi)
                ];
            },
            'Coral': (i, size = 20) => {
                const branch = Math.floor(i / (config.particleCount / 8));
                const posInBranch = (i % (config.particleCount / 8)) / (config.particleCount / 8);
                const angle = branch * Math.PI * 0.25;
                const length = size * (0.2 + 0.8 * posInBranch);
                const width = size * 0.1 * (1 - posInBranch);
                const wave = Math.sin(posInBranch * Math.PI * 5) * 0.5;
                return [
                    Math.cos(angle + wave) * length,
                    Math.sin(angle + wave) * length,
                    (Math.random() - 0.5) * width
                ];
            },
            'Jellyfish': (i, radius = 15) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const tentacle = Math.floor(i / (config.particleCount / 10)) % 10;
                const pulse = Math.sin(Date.now() * 0.001 + tentacle * 0.3) * 0.2;
                return [
                    radius * (0.8 + pulse) * Math.sin(phi) * Math.cos(theta + tentacle * 0.2),
                    radius * (0.8 + pulse) * Math.sin(phi) * Math.sin(theta + tentacle * 0.2),
                    radius * Math.cos(phi) * 0.5
                ];
            },
            'Seaweed': (i, size = 20) => {
                const strand = Math.floor(i / (config.particleCount / 5));
                const pos = (i % (config.particleCount / 5)) / (config.particleCount / 5);
                const wave = Math.sin(pos * Math.PI * 5 + strand * 0.5) * 0.5;
                return [
                    size * 0.3 * Math.cos(strand * Math.PI * 0.4 + wave),
                    size * 0.3 * Math.sin(strand * Math.PI * 0.4 + wave),
                    size * (pos - 0.5)
                ];
            },
            'Butterfly': (i, size = 15) => {
                const wing = Math.floor(i / (config.particleCount / 4)) % 4;
                const pos = (i % (config.particleCount / 4)) / (config.particleCount / 4);
                const angle = pos * Math.PI;
                const x = size * 0.5 * Math.cos(angle);
                const y = size * Math.sin(angle) * (0.3 + 0.7 * Math.abs(Math.cos(angle)));
                const side = wing < 2 ? -1 : 1;
                const layer = wing % 2;
                return [
                    x * side,
                    y,
                    (layer - 0.5) * size * 0.2
                ];
            },
            'SpiderWeb': (i, radius = 20) => {
                const radialLines = 8;
                const circles = 5;
                const line = Math.floor(i / (config.particleCount / (radialLines + circles)));
                
                if (line < radialLines) {
                    // Radial lines
                    const angle = line * Math.PI * 2 / radialLines;
                    const distance = radius * (0.1 + 0.9 * Math.random());
                    return [
                        distance * Math.cos(angle),
                        distance * Math.sin(angle),
                        (Math.random() - 0.5) * radius * 0.1
                    ];
                } else {
                    // Circles
                    const circle = line - radialLines;
                    const angle = Math.random() * Math.PI * 2;
                    const distance = radius * (0.2 + 0.8 * circle / circles);
                    return [
                        distance * Math.cos(angle),
                        distance * Math.sin(angle),
                        (Math.random() - 0.5) * radius * 0.1
                    ];
                }
            },
            'Bacteria': (i, size = 15) => {
                const colony = Math.floor(i / (config.particleCount / 5));
                const angle = Math.random() * Math.PI * 2;
                const distance = size * 0.3 * Math.random();
                return [
                    size * 0.2 * colony + distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    (Math.random() - 0.5) * size * 0.3
                ];
            },
            'Virus': (i, radius = 12) => {
                const spikes = 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const spike = Math.floor(i / (config.particleCount / spikes)) % spikes;
                const spikeFactor = 1 + 0.5 * Math.sin(phi * spikes + spike * 0.3);
                return [
                    radius * spikeFactor * Math.sin(phi) * Math.cos(theta),
                    radius * spikeFactor * Math.sin(phi) * Math.sin(theta),
                    radius * spikeFactor * Math.cos(phi)
                ];
            },
            'CellDivision': (i, size = 15) => {
                const stage = Math.floor(i / (config.particleCount / 4)) % 4;
                const angle = Math.random() * Math.PI * 2;
                const distance = size * 0.3 * Math.random();
                const offset = size * 0.2 * (stage - 1.5);
                return [
                    offset + distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    (Math.random() - 0.5) * size * 0.2
                ];
            },
            'Microbiome': (i, size = 20) => {
                const organism = Math.floor(i / (config.particleCount / 10)) % 10;
                const angle = Math.random() * Math.PI * 2;
                const distance = size * 0.2 * Math.random();
                const x = size * (organism / 10 - 0.5) * 0.8;
                return [
                    x + distance * Math.cos(angle),
                    distance * Math.sin(angle),
                    (Math.random() - 0.5) * size * 0.3
                ];
            },

            // Mathematical Shapes (20)
            'Spiral': (i, radius = 15, height = 30) => {
                const t = i / config.particleCount * Math.PI * 10;
                return [
                    radius * Math.cos(t),
                    radius * Math.sin(t),
                    height * (i / config.particleCount - 0.5)
                ];
            },
            'MobiusStrip': (i, radius = 15) => {
                const t = i / config.particleCount * Math.PI * 2;
                const width = 5;
                return [
                    (radius + width * Math.cos(t * 0.5)) * Math.cos(t),
                    (radius + width * Math.cos(t * 0.5)) * Math.sin(t),
                    width * Math.sin(t * 0.5)
                ];
            },
            'KleinBottle': (i, size = 20) => {
                // Simplified approximation
                const u = i / config.particleCount * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const r = 4 * (1 - Math.cos(u) / 2);
                return [
                    size * 0.1 * (6 * Math.cos(u) * (1 + Math.sin(u)) + r * Math.cos(u) * Math.cos(v)),
                    size * 0.1 * (16 * Math.sin(u) + r * Math.sin(u) * Math.cos(v)),
                    size * 0.1 * (r * Math.sin(v))
                ];
            },
            'TorusKnot': (i, radius = 15, tube = 3, p = 2, q = 3) => {
                const t = i / config.particleCount * Math.PI * 2 * q;
                const r = 0.5 * (2 + Math.sin(p / q * t));
                return [
                    radius * r * Math.cos(t),
                    radius * r * Math.sin(t),
                    tube * Math.cos(p / q * t)
                ];
            },
            'Saddle': (i, size = 20) => {
                const x = size * (Math.random() - 0.5);
                const y = size * (Math.random() - 0.5);
                return [
                    x,
                    y,
                    size * 0.1 * (x * x - y * y) / size
                ];
            },
            'Paraboloid': (i, size = 20) => {
                const theta = Math.random() * Math.PI * 2;
                const r = size * 0.5 * Math.sqrt(Math.random());
                return [
                    r * Math.cos(theta),
                    r * Math.sin(theta),
                    size * 0.1 * (r * r) / (size * size)
                ];
            },
            'Hyperboloid': (i, size = 20) => {
                const theta = Math.random() * Math.PI * 2;
                const r = size * 0.5 * Math.sqrt(1 + Math.random());
                return [
                    r * Math.cos(theta),
                    r * Math.sin(theta),
                    size * 0.1 * Math.sqrt(r * r - size * size * 0.25) / size
                ];
            },
            'Helicoid': (i, radius = 15, height = 30) => {
                const t = i / config.particleCount * Math.PI * 8;
                return [
                    radius * Math.cos(t),
                    radius * Math.sin(t),
                    height * (i / config.particleCount - 0.5)
                ];
            },
            'Catenoid': (i, radius = 15) => {
                const theta = Math.random() * Math.PI * 2;
                const u = (Math.random() - 0.5) * 2;
                return [
                    radius * Math.cosh(u) * Math.cos(theta),
                    radius * Math.cosh(u) * Math.sin(theta),
                    radius * u
                ];
            },
            'EnneperSurface': (i, size = 15) => {
                const u = (Math.random() - 0.5) * 2;
                const v = (Math.random() - 0.5) * 2;
                return [
                    size * 0.2 * (u - u*u*u/3 + u*v*v),
                    size * 0.2 * (v - v*v*v/3 + v*u*u),
                    size * 0.2 * (u*u - v*v)
                ];
            },
            'SineWave': (i, size = 20) => {
                const x = size * (Math.random() - 0.5);
                const y = size * (Math.random() - 0.5);
                return [
                    x,
                    y,
                    size * 0.2 * Math.sin(x * 0.3) * Math.cos(y * 0.3)
                ];
            },
            'WaveGrid': (i, size = 20) => {
                const gridSize = Math.ceil(Math.sqrt(config.particleCount));
                const x = (i % gridSize) / gridSize * size - size/2;
                const y = Math.floor(i / gridSize) / gridSize * size - size/2;
                const wave = Math.sin(x * 0.5 + Date.now() * 0.001) * 3;
                return [
                    x,
                    y,
                    wave * Math.cos(y * 0.3)
                ];
            },
            'FibonacciSphere': (i, radius = 15) => {
                const n = config.particleCount;
                const idx = i + 0.5;
                const phi = Math.acos(1 - 2 * idx / n);
                const theta = Math.PI * (1 + Math.sqrt(5)) * idx;
                return [
                    radius * Math.cos(theta) * Math.sin(phi),
                    radius * Math.sin(theta) * Math.sin(phi),
                    radius * Math.cos(phi)
                ];
            },
            'Lissajous': (i, size = 20) => {
                const t = i / config.particleCount * Math.PI * 10;
                return [
                    size * 0.4 * Math.sin(2 * t),
                    size * 0.4 * Math.sin(3 * t),
                    size * 0.4 * Math.sin(5 * t)
                ];
            },
            'CliffordAttractor': (i, size = 20) => {
                // Parameters for the attractor
                const a = -1.4, b = 1.6, c = 1.0, d = 0.7;
                let x = 0, y = 0;
                
                // Iterate to get a point on the attractor
                for (let j = 0; j < 100; j++) {
                    const newX = Math.sin(a * y) + c * Math.cos(a * x);
                    const newY = Math.sin(b * x) + d * Math.cos(b * y);
                    x = newX;
                    y = newY;
                }
                
                return [
                    size * 0.3 * x,
                    size * 0.3 * y,
                    (Math.random() - 0.5) * size * 0.2
                ];
            },
            'HenonAttractor': (i, size = 20) => {
                // Parameters for the attractor
                const a = 1.4, b = 0.3;
                let x = 0, y = 0;
                
                // Iterate to get a point on the attractor
                for (let j = 0; j < 100; j++) {
                    const newX = 1 - a * x * x + y;
                    const newY = b * x;
                    x = newX;
                    y = newY;
                }
                
                return [
                    size * 0.4 * x,
                    size * 0.4 * y,
                    (Math.random() - 0.5) * size * 0.2
                ];
            },
            'JuliaSet': (i, size = 20) => {
                // Parameters for Julia set
                const cRe = -0.7, cIm = 0.27;
                let zRe = (Math.random() - 0.5) * 2;
                let zIm = (Math.random() - 0.5) * 2;
                
                // Iterate to get a point in the set
                for (let j = 0; j < 20; j++) {
                    const newRe = zRe * zRe - zIm * zIm + cRe;
                    const newIm = 2 * zRe * zIm + cIm;
                    zRe = newRe;
                    zIm = newIm;
                }
                
                return [
                    size * 0.4 * zRe,
                    size * 0.4 * zIm,
                    (Math.random() - 0.5) * size * 0.2
                ];
            },
            'Mandelbrot': (i, size = 20) => {
                // Generate points around the Mandelbrot set
                const cRe = (Math.random() - 0.5) * 2.5;
                const cIm = (Math.random() - 0.5) * 2;
                let zRe = 0, zIm = 0;
                let escaped = false;
                
                // Iterate to see if point escapes
                for (let j = 0; j < 20; j++) {
                    if (zRe * zRe + zIm * zIm > 4) {
                        escaped = true;
                        break;
                    }
                    const newRe = zRe * zRe - zIm * zIm + cRe;
                    const newIm = 2 * zRe * zIm + cIm;
                    zRe = newRe;
                    zIm = newIm;
                }
                
                return [
                    size * 0.4 * cRe,
                    size * 0.4 * cIm,
                    escaped ? (Math.random() - 0.5) * size * 0.1 : 0
                ];
            },
            'StrangeAttractor': (i, size = 20) => {
                // Random parameters for a strange attractor
                const a = Math.random() * 2 - 1;
                const b = Math.random() * 2 - 1;
                const c = Math.random() * 2 - 1;
                const d = Math.random() * 2 - 1;
                let x = 0, y = 0, z = 0;
                
                // Iterate to get a point on the attractor
                for (let j = 0; j < 100; j++) {
                    const newX = Math.sin(a * y) - z * Math.cos(b * x);
                    const newY = z * Math.sin(c * x) - Math.cos(d * y);
                    const newZ = Math.sin(x);
                    x = newX;
                    y = newY;
                    z = newZ;
                }
                
                return [
                    size * 0.3 * x,
                    size * 0.3 * y,
                    size * 0.3 * z
                ];
            },

            // Structural Shapes (20)
            'EiffelTower': (i, size = 25) => {
                const level = Math.floor(i / (config.particleCount / 10));
                const pos = (i % (config.particleCount / 10)) / (config.particleCount / 10);
                const baseWidth = size * (1 - level / 15);
                const height = size * level / 10;
                const angle = Math.random() * Math.PI * 2;
                return [
                    baseWidth * 0.5 * Math.cos(angle),
                    baseWidth * 0.5 * Math.sin(angle),
                    height
                ];
            },
            'Bridge': (i, size = 25) => {
                const x = size * (Math.random() - 0.5);
                const z = size * (Math.random() - 0.5) * 0.2;
                const cable = Math.sin(Math.abs(x) * 0.3) * size * 0.3;
                return [
                    x,
                    cable * (1 - Math.abs(x) / size),
                    z
                ];
            },
            'Skyscraper': (i, size = 25) => {
                const x = size * (Math.random() - 0.5) * 0.2;
                const y = size * (Math.random() - 0.5) * 0.2;
                const z = size * Math.random() * 0.8;
                return [
                    x,
                    y,
                    z
                ];
            },
            'Arch': (i, size = 20) => {
                const angle = Math.random() * Math.PI;
                const height = size * Math.sin(angle) * 0.8;
                return [
                    size * 0.5 * Math.cos(angle),
                    size * 0.1 * (Math.random() - 0.5),
                    height
                ];
            },
            'Dome': (i, size = 20) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1) * 0.5;
                return [
                    size * Math.sin(phi) * Math.cos(theta),
                    size * Math.sin(phi) * Math.sin(theta),
                    size * Math.cos(phi)
                ];
            },
            'Fence': (i, size = 20) => {
                const posts = 20;
                const post = Math.floor(i / (config.particleCount / posts)) % posts;
                const pos = (i % (config.particleCount / posts)) / (config.particleCount / posts);
                const x = size * (post / posts - 0.5);
                const height = size * 0.2;
                return [
                    x,
                    (pos - 0.5) * size * 0.1,
                    height * (0.5 + 0.5 * Math.sin(post * 0.3))
                ];
            },
            'Staircase': (i, size = 20) => {
                const steps = 20;
                const step = Math.floor(i / (config.particleCount / steps)) % steps;
                const pos = (i % (config.particleCount / steps)) / (config.particleCount / steps);
                return [
                    size * (pos - 0.5),
                    size * 0.1 * (Math.random() - 0.5),
                    size * step / steps
                ];
            },
            'FerrisWheel': (i, radius = 15) => {
                const spokes = 12;
                const spoke = Math.floor(i / (config.particleCount / spokes)) % spokes;
                const angle = spoke * Math.PI * 2 / spokes;
                const pos = (i % (config.particleCount / spokes)) / (config.particleCount / spokes);
                return [
                    radius * Math.cos(angle),
                    radius * Math.sin(angle),
                    radius * (pos - 0.5) * 0.2
                ];
            },
            'RollerCoaster': (i, size = 25) => {
                const t = i / config.particleCount * Math.PI * 10;
                const loop = Math.floor(t / (Math.PI * 2)) % 3;
                const loopHeight = size * 0.2 * loop;
                return [
                    size * 0.3 * Math.cos(t),
                    size * 0.3 * Math.sin(t),
                    loopHeight + size * 0.1 * Math.sin(t * 2)
                ];
            },
            'SatelliteDish': (i, size = 15) => {
                const theta = Math.random() * Math.PI * 2;
                const r = size * Math.sqrt(Math.random());
                const z = size * 0.1 * (1 - r * r / (size * size));
                return [
                    r * Math.cos(theta),
                    r * Math.sin(theta),
                    z
                ];
            },
            'RadioTower': (i, size = 25) => {
                const section = Math.floor(i / (config.particleCount / 5));
                const height = size * section / 5;
                const width = size * (1 - section / 10) * 0.2;
                const angle = Math.random() * Math.PI * 2;
                return [
                    width * Math.cos(angle),
                    width * Math.sin(angle),
                    height
                ];
            },
            'WindTurbine': (i, size = 25) => {
                const blade = Math.floor(i / (config.particleCount / 4)) % 4;
                if (blade === 0) {
                    // Tower
                    return [
                        size * 0.05 * (Math.random() - 0.5),
                        size * 0.05 * (Math.random() - 0.5),
                        size * Math.random()
                    ];
                } else {
                    // Blades
                    const angle = (blade - 1) * Math.PI * 2 / 3 + Date.now() * 0.001;
                    const r = size * 0.4;
                    const pos = (i % (config.particleCount / 4)) / (config.particleCount / 4);
                    return [
                        r * pos * Math.cos(angle),
                        r * pos * Math.sin(angle),
                        size * 0.8
                    ];
                }
            },
            'SuspensionBridge': (i, size = 25) => {
                const x = size * (Math.random() - 0.5);
                const z = size * (Math.random() - 0.5) * 0.2;
                const cable = size * 0.3 * (1 - Math.abs(x) / size * 2);
                return [
                    x,
                    cable * (0.5 + 0.5 * Math.sin(x * 0.3)),
                    z
                ];
            },
            'LatticeTower': (i, size = 25) => {
                const levels = 10;
                const level = Math.floor(i / (config.particleCount / levels)) % levels;
                const height = size * level / levels;
                const width = size * (1 - level / 20) * 0.3;
                const edge = Math.floor((i % (config.particleCount / levels)) / (config.particleCount / levels / 4)) % 4;
                const pos = (i % (config.particleCount / levels / 4)) / (config.particleCount / levels / 4);
                
                switch(edge) {
                    case 0: return [width * (pos - 0.5), -width * 0.5, height];
                    case 1: return [width * 0.5, width * (pos - 0.5), height];
                    case 2: return [width * (0.5 - pos), width * 0.5, height];
                    case 3: return [-width * 0.5, width * (0.5 - pos), height];
                }
            },
            'SpaceNeedle': (i, size = 25) => {
                const section = Math.floor(i / (config.particleCount / 3));
                const height = size * section / 3;
                let width;
                if (section === 0) width = size * 0.1;
                else if (section === 1) width = size * 0.2;
                else width = size * 0.05;
                
                const angle = Math.random() * Math.PI * 2;
                return [
                    width * Math.cos(angle),
                    width * Math.sin(angle),
                    height
                ];
            },
            'GoldenGate': (i, size = 25) => {
                const x = size * (Math.random() - 0.5);
                const z = size * (Math.random() - 0.5) * 0.2;
                const cable = size * 0.3 * (1 - Math.abs(x) / size * 1.5);
                return [
                    x,
                    cable * (0.7 + 0.3 * Math.sin(x * 0.2)),
                    z
                ];
            },
            'Pagoda': (i, size = 25) => {
                const levels = 5;
                const level = Math.floor(i / (config.particleCount / levels)) % levels;
                const height = size * level / levels;
                const width = size * (1 - level / 10) * 0.3;
                const angle = Math.random() * Math.PI * 2;
                const roofOffset = level % 2 === 0 ? size * 0.05 : 0;
                return [
                    width * Math.cos(angle),
                    width * Math.sin(angle),
                    height + roofOffset
                ];
            },
            'OilRig': (i, size = 25) => {
                const section = Math.floor(i / (config.particleCount / 4));
                if (section === 0) {
                    // Platform
                    return [
                        size * 0.3 * (Math.random() - 0.5),
                        size * 0.3 * (Math.random() - 0.5),
                        size * 0.1
                    ];
                } else if (section === 1) {
                    // Legs
                    const leg = Math.floor((i % (config.particleCount / 4)) / (config.particleCount / 16)) % 4;
                    const height = size * 0.8 * Math.random();
                    const angle = leg * Math.PI * 0.5;
                    return [
                        size * 0.2 * Math.cos(angle),
                        size * 0.2 * Math.sin(angle),
                        height
                    ];
                } else if (section === 2) {
                    // Crane
                    return [
                        size * 0.4,
                        size * 0.1 * (Math.random() - 0.5),
                        size * (0.2 + 0.6 * Math.random())
                    ];
                } else {
                    // Drill
                    return [
                        size * 0.1 * (Math.random() - 0.5),
                        size * 0.1 * (Math.random() - 0.5),
                        -size * 0.5 * Math.random()
                    ];
                }
            },
            'WaterTower': (i, size = 20) => {
                const section = Math.floor(i / (config.particleCount / 3));
                if (section === 0) {
                    // Tank
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    return [
                        size * 0.3 * Math.sin(phi) * Math.cos(theta),
                        size * 0.3 * Math.sin(phi) * Math.sin(theta),
                        size * 0.5 + size * 0.3 * Math.cos(phi)
                    ];
                } else if (section === 1) {
                    // Support
                    const angle = Math.random() * Math.PI * 2;
                    const height = size * 0.5 * Math.random();
                    return [
                        size * 0.1 * Math.cos(angle),
                        size * 0.1 * Math.sin(angle),
                        height
                    ];
                } else {
                    // Base
                    return [
                        size * 0.2 * (Math.random() - 0.5),
                        size * 0.2 * (Math.random() - 0.5),
                        size * 0.05 * Math.random()
                    ];
                }
            },
            'Lighthouse': (i, size = 20) => {
                const section = Math.floor(i / (config.particleCount / 3));
                if (section === 0) {
                    // Tower
                    const angle = Math.random() * Math.PI * 2;
                    const height = size * (0.2 + 0.6 * Math.random());
                    return [
                        size * 0.1 * Math.cos(angle),
                        size * 0.1 * Math.sin(angle),
                        height
                    ];
                } else if (section === 1) {
                    // Light room
                    const theta = Math.random() * Math.PI * 2;
                    return [
                        size * 0.15 * Math.cos(theta),
                        size * 0.15 * Math.sin(theta),
                        size * 0.8
                    ];
                } else {
                    // Base
                    return [
                        size * 0.2 * (Math.random() - 0.5),
                        size * 0.2 * (Math.random() - 0.5),
                        size * 0.1 * Math.random()
                    ];
                }
            }
        };

        // Morphing variables
        let isMorphing = false;
        let morphProgress = 0;
        let nextShape = 'Sphere';
        let autoMorphTimeout;

        // Generate new target shape
        function generateNewShape(shapeName = null) {
            if (isMorphing) return;
            
            const shapeKeys = Object.keys(shapes);
            const customShapeKeys = Object.keys(customShapes);
            if (!shapeName) {
                // Combine both built-in and custom shapes
                const allShapes = shapeKeys.concat(customShapeKeys);
                if (allShapes.length === 0) return;

                do {
                    shapeName = allShapes[Math.floor(Math.random() * allShapes.length)];
                } while (shapeName === config.currentShape && allShapes.length > 1);
            }
            
            nextShape = shapeName;
            config.currentShape = nextShape;
            
            // Update UI
            document.getElementById('current-shape').textContent = nextShape;
            
            if (customShapes[nextShape]) {
                // Use custom shape positions
                for (let i = 0; i < config.particleCount * 3; i++) {
                    targetPositions[i] = customShapes[nextShape][i];
                }
            } else if (shapes[nextShape]) {
                // Generate using built-in shape function
                for (let i = 0; i < config.particleCount; i++) {
                    const newPos = shapes[nextShape](i);
                    targetPositions[i * 3] = newPos[0];
                    targetPositions[i * 3 + 1] = newPos[1];
                    targetPositions[i * 3 + 2] = newPos[2];
                }
            } else {
                console.error("Shape not found: ", nextShape);
                return;
            }
            
            isMorphing = true;
            morphProgress = 0;
            
            // Update connections after morph completes
            setTimeout(() => {
                createConnections();
            }, 1000 / config.morphSpeed);
            
            // Schedule next auto-morph
            if (config.autoMorph) {
                clearTimeout(autoMorphTimeout);
                autoMorphTimeout = setTimeout(() => {
                    generateNewShape();
                }, config.autoMorphDelay);
            }
        }

        // Save current particle positions as a custom shape
        function saveCustomShape(name) {
            if (!name || name.trim() === '') {
                showNotification("Please enter a valid name", "#ff5555");
                return;
            }
            
            if (customShapes[name]) {
                showNotification(`Overwriting shape "${name}"`, "#ffaa00");
            } else {
                showNotification(`Shape "${name}" saved`, "#00cc88");
            }
            
            // Create a copy of current positions
            const currentPositions = new Float32Array(positions);
            customShapes[name] = currentPositions;
            
            // Save to localStorage
            const shapesForStorage = {};
            for (const key in customShapes) {
                shapesForStorage[key] = Array.from(customShapes[key]);
            }
            localStorage.setItem('customParticleShapes', JSON.stringify(shapesForStorage));
            
            // Update UI
            renderSavedShapes();
            
            // Clear input
            document.getElementById('shape-name').value = '';
        }
        
        // Show notification
        function showNotification(message, color) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.background = color;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // Render saved shapes in UI
        function renderSavedShapes() {
            const container = document.getElementById('saved-shapes');
            container.innerHTML = '';
            
            for (const [name] of Object.entries(customShapes)) {
                const shapeEl = document.createElement('div');
                shapeEl.className = 'saved-shape';
                
                shapeEl.innerHTML = `
                    <div class="saved-shape-name">${name}</div>
                    <div class="saved-shape-actions">
                        <button class="action-btn morph-btn" data-name="${name}">Morph</button>
                        <button class="action-btn delete-btn" data-name="${name}">Delete</button>
                    </div>
                `;
                
                container.appendChild(shapeEl);
            }
        }
        
        // Load saved shapes from localStorage
        function loadCustomShapes() {
            const storedShapes = localStorage.getItem('customParticleShapes');
            if (storedShapes) {
                try {
                    const parsedShapes = JSON.parse(storedShapes);
                    for (const [name, positions] of Object.entries(parsedShapes)) {
                        customShapes[name] = new Float32Array(positions);
                    }
                    renderSavedShapes();
                } catch (e) {
                    console.error("Error loading custom shapes:", e);
                    localStorage.removeItem('customParticleShapes');
                }
            }
        }
        
        // Remove a custom shape
        function removeCustomShape(name) {
            if (customShapes[name]) {
                delete customShapes[name];
                // Update localStorage
                const shapesForStorage = {};
                for (const key in customShapes) {
                    shapesForStorage[key] = Array.from(customShapes[key]);
                }
                localStorage.setItem('customParticleShapes', JSON.stringify(shapesForStorage));
                renderSavedShapes();
                showNotification(`Deleted shape "${name}"`, "#ff5577");
            }
        }

        // Setup UI controls
        function setupControls() {
            // Set initial values
            document.getElementById('particleCount').value = config.particleCount;
            document.getElementById('particleSize').value = config.particleSize;
            document.getElementById('particleOpacity').value = config.particleOpacity;
            document.getElementById('baseColor').value = config.baseColor;
            document.getElementById('highlightColor').value = config.highlightColor;
            document.getElementById('particleType').value = config.particleType;
            document.getElementById('morphSpeed').value = config.morphSpeed;
            document.getElementById('rotationSpeedX').value = config.rotationSpeedX;
            document.getElementById('rotationSpeedY').value = config.rotationSpeedY;
            document.getElementById('autoMorph').checked = config.autoMorph;
            document.getElementById('autoMorphDelay').value = config.autoMorphDelay;
            document.getElementById('connectionDensity').value = config.connectionDensity;
            document.getElementById('connectionWidth').value = config.connectionWidth;
            
            // Setup event listeners
            document.getElementById('particleCount').addEventListener('input', e => {
                config.particleCount = parseInt(e.target.value);
                document.getElementById('particle-count').textContent = config.particleCount;
                resetParticles();
            });
            
            document.getElementById('particleSize').addEventListener('input', e => {
                config.particleSize = parseFloat(e.target.value);
                updateParticleMaterial();
            });
            
            document.getElementById('particleOpacity').addEventListener('input', e => {
                config.particleOpacity = parseFloat(e.target.value);
                updateParticleMaterial();
            });
            
            document.getElementById('baseColor').addEventListener('input', e => {
                config.baseColor = e.target.value;
                updateColors();
            });
            
            document.getElementById('highlightColor').addEventListener('input', e => {
                config.highlightColor = e.target.value;
                updateColors();
            });
            
            document.getElementById('particleType').addEventListener('change', e => {
                config.particleType = e.target.value;
                updateParticleMaterial();
            });
            
            document.getElementById('morphSpeed').addEventListener('input', e => {
                config.morphSpeed = parseFloat(e.target.value);
            });
            
            document.getElementById('rotationSpeedX').addEventListener('input', e => {
                config.rotationSpeedX = parseFloat(e.target.value);
            });
            
            document.getElementById('rotationSpeedY').addEventListener('input', e => {
                config.rotationSpeedY = parseFloat(e.target.value);
            });
            
            document.getElementById('autoMorph').addEventListener('change', e => {
                config.autoMorph = e.target.checked;
                toggleAutoMorph();
            });
            
            document.getElementById('autoMorphDelay').addEventListener('input', e => {
                config.autoMorphDelay = parseInt(e.target.value);
            });
            
            document.getElementById('connectionDensity').addEventListener('input', e => {
                config.connectionDensity = parseFloat(e.target.value);
                createConnections();
            });
            
            document.getElementById('connectionWidth').addEventListener('input', e => {
                config.connectionWidth = parseFloat(e.target.value);
                connectionMaterial.linewidth = config.connectionWidth;
            });
            
            // Shape buttons
            function createShapeButtons() {
                const shapeCategories = {
                    'basic-shapes': [
                        'Sphere', 'Cube', 'Torus', 'Cylinder', 'Cone', 'Pyramid', 'Diamond', 
                        'DoublePyramid', 'SphericalShell', 'BoxFrame', 'SpikySphere', 'WavySphere',
                        'TwistedTorus', 'LayeredSphere', 'HollowCube', 'SpiralStaircase', 
                        'TwistedColumn', 'FractalCube', 'MengerSponge', 'Tetrahedron'
                    ],
                    'scientific-shapes': [
                        'Atom', 'DNA', 'Molecule', 'SolarSystem', 'Galaxy', 'SpiralGalaxy',
                        'BlackHole', 'Nebula', 'QuantumOrbitals', 'ParticleAccelerator',
                        'CrystalLattice', 'FCC_Lattice', 'BCC_Lattice', 'GrapheneSheet',
                        'CarbonNanotube', 'SuperconductorVortex', 'MagneticField',
                        'QuantumFoam', 'HiggsField', 'StringTheory'
                    ],
                    'organic-shapes': [
                        'Heart', 'Flower', 'Tree', 'FractalTree', 'Leaf', 'DNA_Strand',
                        'Neuron', 'BloodVessels', 'Lungs', 'Brain', 'Coral', 'Jellyfish',
                        'Seaweed', 'Butterfly', 'SpiderWeb', 'Bacteria', 'Virus',
                        'CellDivision', 'Microbiome'
                    ],
                    'math-shapes': [
                        'Spiral', 'MobiusStrip', 'KleinBottle', 'TorusKnot', 'Saddle',
                        'Paraboloid', 'Hyperboloid', 'Helicoid', 'Catenoid', 'EnneperSurface',
                        'SineWave', 'WaveGrid', 'FibonacciSphere', 'Lissajous',
                        'CliffordAttractor', 'HenonAttractor', 'JuliaSet', 'Mandelbrot',
                        'StrangeAttractor'
                    ],
                    'structural-shapes': [
                        'EiffelTower', 'Bridge', 'Skyscraper', 'Arch', 'Dome', 'Fence',
                        'Staircase', 'FerrisWheel', 'RollerCoaster', 'SatelliteDish',
                        'RadioTower', 'WindTurbine', 'SuspensionBridge', 'LatticeTower',
                        'SpaceNeedle', 'GoldenGate', 'Pagoda', 'OilRig', 'WaterTower',
                        'Lighthouse'
                    ]
                };
                
                for (const [containerId, shapeList] of Object.entries(shapeCategories)) {
                    const container = document.getElementById(containerId);
                    container.innerHTML = '';
                    
                    for (const shape of shapeList) {
                        const btn = document.createElement('button');
                        btn.className = 'shape-btn';
                        btn.textContent = shape;
                        btn.dataset.shape = shape;
                        btn.addEventListener('click', () => generateNewShape(shape));
                        container.appendChild(btn);
                    }
                }
            }
            
            createShapeButtons();
            
            // Save shape button
            document.getElementById('save-shape').addEventListener('click', () => {
                saveCustomShape(document.getElementById('shape-name').value);
            });
            
            // Shape search
            document.getElementById('shape-search').addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                document.querySelectorAll('.shape-btn').forEach(btn => {
                    const shapeName = btn.textContent.toLowerCase();
                    btn.style.display = shapeName.includes(searchTerm) ? 'block' : 'none';
                });
            });
            
            // Toggle GUI button
            document.getElementById('toggle-gui').addEventListener('click', () => {
                document.getElementById('gui').classList.toggle('hidden');
            });
        }
        
        function updateParticleMaterial() {
            scene.remove(particleSystem);
            particleMaterial = createParticleMaterial();
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        function updateColors() {
            const baseRgb = hexToRgb(config.baseColor);
            const highlightRgb = hexToRgb(config.highlightColor);
            
            for (let i = 0; i < config.particleCount; i++) {
                const mixFactor = Math.random();
                colors[i * 3] = baseRgb[0] * (1 - mixFactor) + highlightRgb[0] * mixFactor;
                colors[i * 3 + 1] = baseRgb[1] * (1 - mixFactor) + highlightRgb[1] * mixFactor;
                colors[i * 3 + 2] = baseRgb[2] * (1 - mixFactor) + highlightRgb[2] * mixFactor;
            }
            
            particles.attributes.color.needsUpdate = true;
        }
        
        function resetParticles() {
            // Reinitialize particles
            scene.remove(particleSystem);
            particles = new THREE.BufferGeometry();
            positions = new Float32Array(config.particleCount * 3);
            colors = new Float32Array(config.particleCount * 3);
            sizes = new Float32Array(config.particleCount);
            originalPositions = new Float32Array(config.particleCount * 3);
            targetPositions = new Float32Array(config.particleCount * 3);
            
            initParticles();
            particleMaterial = createParticleMaterial();
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            
            // Reset connections
            createConnections();
            
            // Reset morph state
            isMorphing = false;
            clearTimeout(autoMorphTimeout);
            config.currentShape = 'Sphere';
            
            if (config.autoMorph) {
                autoMorphTimeout = setTimeout(() => {
                    generateNewShape();
                }, config.autoMorphDelay);
            }
        }
        
        function toggleAutoMorph() {
            if (config.autoMorph) {
                autoMorphTimeout = setTimeout(() => {
                    generateNewShape();
                }, config.autoMorphDelay);
            } else {
                clearTimeout(autoMorphTimeout);
            }
        }

        // Event listeners
        document.addEventListener('click', (e) => {
            if (e.ctrlKey || e.metaKey) {
                // Ctrl+Click - save current as custom shape
                document.getElementById('shape-name').focus();
            } else {
                // Regular click - morph to new shape
                generateNewShape();
            }
        });
        
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const types = ['circle', 'square', 'star', 'glow'];
            const currentIndex = types.indexOf(config.particleType);
            config.particleType = types[(currentIndex + 1) % types.length];
            document.getElementById('particleType').value = config.particleType;
            updateParticleMaterial();
        });

        // Handle saved shape actions
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('morph-btn')) {
                generateNewShape(e.target.dataset.name);
            }
            if (e.target.classList.contains('delete-btn')) {
                removeCustomShape(e.target.dataset.name);
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            // Rotate
            particleSystem.rotation.x += config.rotationSpeedX;
            particleSystem.rotation.y += config.rotationSpeedY;

            // Handle morphing
            if (isMorphing) {
                morphProgress += config.morphSpeed;
                
                for (let i = 0; i < config.particleCount * 3; i++) {
                    positions[i] = originalPositions[i] + (targetPositions[i] - originalPositions[i]) * morphProgress;
                }
                
                particles.attributes.position.needsUpdate = true;
                
                if (morphProgress >= 1) {
                    isMorphing = false;
                    for (let i = 0; i < config.particleCount * 3; i++) {
                        originalPositions[i] = positions[i];
                    }
                }
            }
            
            // Animate connections
            connections.forEach(conn => {
                conn.progress += conn.speed;
                if (conn.progress > 1) conn.progress = 0;
                
                const startPos = new THREE.Vector3(
                    positions[conn.startIdx * 3],
                    positions[conn.startIdx * 3 + 1],
                    positions[conn.startIdx * 3 + 2]
                );
                
                const endPos = new THREE.Vector3(
                    positions[conn.endIdx * 3],
                    positions[conn.endIdx * 3 + 1],
                    positions[conn.endIdx * 3 + 2]
                );
                
                const midPoint = new THREE.Vector3().lerpVectors(startPos, endPos, conn.progress);
                
                // Update line geometry
                const linePositions = conn.line.geometry.attributes.position;
                linePositions.setXYZ(1, midPoint.x, midPoint.y, midPoint.z);
                linePositions.needsUpdate = true;
            });

            renderer.render(scene, camera);
        }

        // Initialize everything
        function init() {
            setupControls();
            loadCustomShapes();
            
            // Start with a random shape
            generateNewShape();
            
            // Start animation
            animate();
        }

        init();
    </script>
</body>
</html>